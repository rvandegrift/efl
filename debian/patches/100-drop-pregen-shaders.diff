--- a/src/lib/ector/gl/shader/ector_gl_shaders.x
+++ /dev/null
@@ -1,285 +0,0 @@
-/* DO NOT MODIFY THIS FILE AS IT IS AUTO-GENERATED */
-/* IF IT IS CHANGED PLEASE COMMIT THE CHANGES */
-
-static const char fragment_glsl[] =
-   "/* General-purpose fragment shader for all operations in Evas.\n"
-   " * This file can either be used directly by evas at runtime to\n"
-   " * generate its shaders with the appropriate #defines, or passed\n"
-   " * through cpp first (in which case the precision must be manually added).\n"
-   " */\n"
-   "#ifdef GL_ES\n"
-   "# ifdef GL_FRAGMENT_PRECISION_HIGH\n"
-   "precision highp float;\n"
-   "# else\n"
-   "precision mediump float;\n"
-   "# endif\n"
-   "# ifdef SHD_EXTERNAL\n"
-   "extension GL_OES_EGL_image_external : require\n"
-   "#  define SAMPLER_EXTERNAL_OES samplerExternalOES\n"
-   "# endif\n"
-   "#else\n"
-   "# define SAMPLER_EXTERNAL_OES sampler2D\n"
-   "#endif\n"
-   "#ifndef SHD_NOMUL\n"
-   "varying vec4 col;\n"
-   "#endif\n"
-   "#ifdef SHD_EXTERNAL\n"
-   "uniform SAMPLER_EXTERNAL_OES tex;\n"
-   "varying vec2 tex_c;\n"
-   "#elif defined(SHD_TEX)\n"
-   "uniform sampler2D tex;\n"
-   "varying vec2 tex_c;\n"
-   "#endif\n"
-   "#if defined(SHD_NV12) || defined(SHD_YUY2)\n"
-   "uniform sampler2D texuv;\n"
-   "varying vec2 tex_c2;\n"
-   "#endif\n"
-   "#if defined(SHD_YUV)\n"
-   "uniform sampler2D texu;\n"
-   "uniform sampler2D texv;\n"
-   "varying vec2 tex_c2;\n"
-   "varying vec2 tex_c3;\n"
-   "#endif\n"
-   "#ifdef SHD_TEXA\n"
-   "uniform sampler2D texa;\n"
-   "varying vec2 tex_a;\n"
-   "#endif\n"
-   "#if defined(SHD_SAM12) || defined(SHD_SAM21) || defined(SHD_SAM22)\n"
-   "varying vec4 div_s;\n"
-   "# if defined(SHD_SAM12) || defined(SHD_SAM21)\n"
-   "varying vec2 tex_s[2];\n"
-   "# else\n"
-   "varying vec2 tex_s[4];\n"
-   "# endif\n"
-   "#endif\n"
-   "#ifdef SHD_MASK\n"
-   "uniform sampler2D texm;\n"
-   "varying vec2 tex_m;\n"
-   "# if defined(SHD_MASKSAM12) || defined(SHD_MASKSAM21)\n"
-   "varying float maskdiv_s;\n"
-   "varying vec2 masktex_s[2];\n"
-   "# elif defined(SHD_MASKSAM22)\n"
-   "varying float maskdiv_s;\n"
-   "varying vec2 masktex_s[4];\n"
-   "# endif\n"
-   "#endif\n"
-   "#ifdef SHD_ALPHA\n"
-   "# define SWZ aaaa\n"
-   "#else\n"
-   "# ifndef SHD_BGRA\n"
-   "#  if defined(SHD_IMG) && defined(BIGENDIAN)\n"
-   "#   define SWZ gbar\n"
-   "#  else\n"
-   "#   define SWZ bgra\n"
-   "#endif\n"
-   "# else\n"
-   "#  if defined(SHD_IMG) && defined(BIGENDIAN)\n"
-   "#   define SWZ grab\n"
-   "#  else\n"
-   "#   define SWZ rgba\n"
-   "#  endif\n"
-   "# endif\n"
-   "#endif\n"
-   "void main()\n"
-   "{\n"
-   "   vec4 c;\n"
-   "#if defined(SHD_YUV) || defined(SHD_NV12) || defined(SHD_YUY2)\n"
-   "   float r, g, b, y, u, v, vmu;\n"
-   "# if defined(SHD_YUV)\n"
-   "   y = texture2D(tex, tex_c).r;\n"
-   "   u = texture2D(texu, tex_c2).r;\n"
-   "   v = texture2D(texv, tex_c3).r;\n"
-   "# elif defined(SHD_NV12) || defined(SHD_YUY2)\n"
-   "   y = texture2D(tex, tex_c).g;\n"
-   "   u = texture2D(texuv, tex_c2).g;\n"
-   "   v = texture2D(texuv, tex_c2).a;\n"
-   "# endif\n"
-   "// center u and v around 0 for uv and y (with 128/255 for u + v, 16/255 for y)\n"
-   "   u = u - 0.5;\n"
-   "   v = v - 0.5;\n"
-   "# if defined (SHD_YUV_709)\n"
-   "// 709 yuv colorspace for hd content\n"
-   "   y = (y - 0.062) * 1.164;\n"
-   "   vmu = (v * 0.534) + (u * 0.213);\n"
-   "   v = v * 1.793;\n"
-   "   u = u * 2.115;\n"
-   "# else\n"
-   "// 601 colorspace constants (older yuv content)\n"
-   "   y = (y - 0.062) * 1.164;\n"
-   "   vmu = (v * 0.813) + (u * 0.391);\n"
-   "   v = v * 1.596;\n"
-   "   u = u * 2.018;\n"
-   "# endif\n"
-   "// common yuv\n"
-   "   r = y + v;\n"
-   "   g = y - vmu;\n"
-   "   b = y + u;\n"
-   "   c = vec4(r, g, b, 1.0);\n"
-   "#elif defined(SHD_SAM12) || defined(SHD_SAM21)\n"
-   "   vec4 col00 = texture2D(tex, tex_c + tex_s[0]).SWZ;\n"
-   "   vec4 col01 = texture2D(tex, tex_c + tex_s[1]).SWZ;\n"
-   "   c = (col00 + col01) / div_s;\n"
-   "#elif defined(SHD_SAM22)\n"
-   "   vec4 col00 = texture2D(tex, tex_c + tex_s[0]).SWZ;\n"
-   "   vec4 col01 = texture2D(tex, tex_c + tex_s[1]).SWZ;\n"
-   "   vec4 col10 = texture2D(tex, tex_c + tex_s[2]).SWZ;\n"
-   "   vec4 col11 = texture2D(tex, tex_c + tex_s[3]).SWZ;\n"
-   "   c = (col00 + col01 + col10 + col11) / div_s;\n"
-   "#elif defined(SHD_TEX) || defined(SHD_EXTERNAL)\n"
-   "   c = texture2D(tex, tex_c).SWZ;\n"
-   "#else\n"
-   "   c = vec4(1, 1, 1, 1);\n"
-   "#endif\n"
-   "#ifdef SHD_MASK\n"
-   "   float ma;\n"
-   "# if defined(SHD_MASKSAM12) || defined(SHD_MASKSAM21)\n"
-   "   float ma00 = texture2D(texm, tex_m + masktex_s[0]).a;\n"
-   "   float ma01 = texture2D(texm, tex_m + masktex_s[1]).a;\n"
-   "   ma = (ma00 + ma01) / maskdiv_s;\n"
-   "# elif defined(SHD_MASKSAM22)\n"
-   "   float ma00 = texture2D(texm, tex_m + masktex_s[0]).a;\n"
-   "   float ma01 = texture2D(texm, tex_m + masktex_s[1]).a;\n"
-   "   float ma10 = texture2D(texm, tex_m + masktex_s[2]).a;\n"
-   "   float ma11 = texture2D(texm, tex_m + masktex_s[3]).a;\n"
-   "   ma = (ma00 + ma01 + ma10 + ma11) / maskdiv_s;\n"
-   "# else\n"
-   "   ma = texture2D(texm, tex_m).a;\n"
-   "# endif\n"
-   "#endif\n"
-   "   gl_FragColor =\n"
-   "       c\n"
-   "#ifndef SHD_NOMUL\n"
-   "     * col\n"
-   "#endif\n"
-   "#ifdef SHD_MASK\n"
-   "	 * ma\n"
-   "#endif\n"
-   "#ifdef SHD_TEXA\n"
-   "     * texture2D(texa, tex_a).r\n"
-   "#endif\n"
-   "   ;\n"
-   "#ifdef SHD_AFILL\n"
-   "   gl_FragColor.a = 1.0;\n"
-   "#endif\n"
-   "}\n";
-
-static const char vertex_glsl[] =
-   "/* General-purpose vertex shader for all operations in Evas.\n"
-   " * This file can either be used directly by evas at runtime to\n"
-   " * generate its shaders with the appropriate #defines, or passed\n"
-   " * through cpp first (in which case the precision must be manually added).\n"
-   " */\n"
-   "#ifdef GL_ES\n"
-   "precision highp float;\n"
-   "#endif\n"
-   "attribute vec4 vertex;\n"
-   "uniform mat4 mvp;\n"
-   "/* All except nomul */\n"
-   "#ifndef SHD_NOMUL\n"
-   "attribute vec4 color;\n"
-   "varying vec4 col;\n"
-   "#endif\n"
-   "/* All images & fonts */\n"
-   "#if defined(SHD_TEX) || defined(SHD_EXTERNAL)\n"
-   "attribute vec2 tex_coord;\n"
-   "varying vec2 tex_c;\n"
-   "#endif\n"
-   "/* NV12, YUY2 */\n"
-   "#if defined(SHD_NV12) || defined(SHD_YUY2) || defined(SHD_YUV)\n"
-   "attribute vec2 tex_coord2;\n"
-   "varying vec2 tex_c2;\n"
-   "#endif\n"
-   "/* YUV */\n"
-   "#ifdef SHD_YUV\n"
-   "attribute vec2 tex_coord3;\n"
-   "varying vec2 tex_c3;\n"
-   "#endif\n"
-   "/* RGB+A */\n"
-   "#ifdef SHD_TEXA\n"
-   "attribute vec2 tex_coorda;\n"
-   "varying vec2 tex_a;\n"
-   "#endif\n"
-   "/* Sampling */\n"
-   "#if defined(SHD_SAM12) || defined(SHD_SAM21) || defined(SHD_SAM22)\n"
-   "attribute vec2 tex_sample;\n"
-   "varying vec4 div_s;\n"
-   "# if defined(SHD_SAM12) || defined(SHD_SAM21)\n"
-   "varying vec2 tex_s[2];\n"
-   "# else\n"
-   "varying vec2 tex_s[4];\n"
-   "# endif\n"
-   "#endif\n"
-   "/* Masking */\n"
-   "#ifdef SHD_MASK\n"
-   "attribute vec4 mask_coord;\n"
-   "varying vec2 tex_m;\n"
-   "# if defined(SHD_MASKSAM12) || defined(SHD_MASKSAM21)\n"
-   "attribute vec2 tex_masksample;\n"
-   "varying float maskdiv_s;\n"
-   "varying vec2 masktex_s[2];\n"
-   "# elif defined(SHD_MASKSAM22)\n"
-   "attribute vec2 tex_masksample;\n"
-   "varying float maskdiv_s;\n"
-   "varying vec2 masktex_s[4];\n"
-   "# endif\n"
-   "#endif\n"
-   "void main()\n"
-   "{\n"
-   "   gl_Position = mvp * vertex;\n"
-   "#ifndef SHD_NOMUL\n"
-   "   col = color;\n"
-   "#endif\n"
-   "#if defined(SHD_TEX) || defined(SHD_EXTERNAL)\n"
-   "   tex_c = tex_coord;\n"
-   "#endif\n"
-   "#ifdef SHD_NV12\n"
-   "   tex_c2 = tex_coord2 * 0.5;\n"
-   "#endif\n"
-   "#ifdef SHD_YUY2\n"
-   "   tex_c2 = vec2(tex_coord2.x * 0.5, tex_coord2.y);\n"
-   "#endif\n"
-   "#ifdef SHD_YUV\n"
-   "   tex_c2 = tex_coord2;\n"
-   "   tex_c3 = tex_coord3;\n"
-   "#endif\n"
-   "#ifdef SHD_TEXA\n"
-   "   tex_a = tex_coorda;\n"
-   "#endif\n"
-   "#if defined(SHD_SAM12)\n"
-   "   tex_s[0] = vec2(0, -tex_sample.y);\n"
-   "   tex_s[1] = vec2(0,  tex_sample.y);\n"
-   "   div_s = vec4(2, 2, 2, 2);\n"
-   "#elif defined(SHD_SAM21)\n"
-   "   tex_s[0] = vec2(-tex_sample.x, 0);\n"
-   "   tex_s[1] = vec2( tex_sample.x, 0);\n"
-   "   div_s = vec4(2, 2, 2, 2);\n"
-   "#elif defined(SHD_SAM22)\n"
-   "   tex_s[0] = vec2(-tex_sample.x, -tex_sample.y);\n"
-   "   tex_s[1] = vec2( tex_sample.x, -tex_sample.y);\n"
-   "   tex_s[2] = vec2( tex_sample.x,  tex_sample.y);\n"
-   "   tex_s[3] = vec2(-tex_sample.x,  tex_sample.y);\n"
-   "   div_s = vec4(4, 4, 4, 4);\n"
-   "#endif\n"
-   "#if defined(SHD_MASKSAM12)\n"
-   "   masktex_s[0] = vec2(0, -tex_masksample.y);\n"
-   "   masktex_s[1] = vec2(0,  tex_masksample.y);\n"
-   "   maskdiv_s = 2.0;\n"
-   "#elif defined(SHD_MASKSAM21)\n"
-   "   masktex_s[0] = vec2(-tex_masksample.x, 0);\n"
-   "   masktex_s[1] = vec2( tex_masksample.x, 0);\n"
-   "   maskdiv_s = 2.0;\n"
-   "#elif defined(SHD_MASKSAM22)\n"
-   "   masktex_s[0] = vec2(-tex_masksample.x, -tex_masksample.y);\n"
-   "   masktex_s[1] = vec2( tex_masksample.x, -tex_masksample.y);\n"
-   "   masktex_s[2] = vec2( tex_masksample.x,  tex_masksample.y);\n"
-   "   masktex_s[3] = vec2(-tex_masksample.x,  tex_masksample.y);\n"
-   "   maskdiv_s = 4.0;\n"
-   "#endif\n"
-   "#ifdef SHD_MASK\n"
-   "   // mask_coord.w contains the Y-invert flag\n"
-   "   // position on screen in [0..1] range of current pixel\n"
-   "   vec4 mask_Position = mvp * vertex * vec4(0.5, sign(mask_coord.w) * 0.5, 0.5, 0.5) + vec4(0.5, 0.5, 0, 0);\n"
-   "   tex_m = mask_Position.xy * abs(mask_coord.zw) + mask_coord.xy;\n"
-   "#endif\n"
-   "}\n";
-
--- a/src/modules/evas/engines/gl_common/shader/evas_gl_shaders.x
+++ /dev/null
@@ -1,285 +0,0 @@
-/* DO NOT MODIFY THIS FILE AS IT IS AUTO-GENERATED */
-/* IF IT IS CHANGED PLEASE COMMIT THE CHANGES */
-
-static const char fragment_glsl[] =
-   "/* General-purpose fragment shader for all operations in Evas.\n"
-   " * This file can either be used directly by evas at runtime to\n"
-   " * generate its shaders with the appropriate #defines, or passed\n"
-   " * through cpp first (in which case the precision must be manually added).\n"
-   " */\n"
-   "#ifdef GL_ES\n"
-   "# ifdef GL_FRAGMENT_PRECISION_HIGH\n"
-   "precision highp float;\n"
-   "# else\n"
-   "precision mediump float;\n"
-   "# endif\n"
-   "# ifdef SHD_EXTERNAL\n"
-   "extension GL_OES_EGL_image_external : require\n"
-   "#  define SAMPLER_EXTERNAL_OES samplerExternalOES\n"
-   "# endif\n"
-   "#else\n"
-   "# define SAMPLER_EXTERNAL_OES sampler2D\n"
-   "#endif\n"
-   "#ifndef SHD_NOMUL\n"
-   "varying vec4 col;\n"
-   "#endif\n"
-   "#ifdef SHD_EXTERNAL\n"
-   "uniform SAMPLER_EXTERNAL_OES tex;\n"
-   "varying vec2 tex_c;\n"
-   "#elif defined(SHD_TEX)\n"
-   "uniform sampler2D tex;\n"
-   "varying vec2 tex_c;\n"
-   "#endif\n"
-   "#if defined(SHD_NV12) || defined(SHD_YUY2)\n"
-   "uniform sampler2D texuv;\n"
-   "varying vec2 tex_c2;\n"
-   "#endif\n"
-   "#if defined(SHD_YUV)\n"
-   "uniform sampler2D texu;\n"
-   "uniform sampler2D texv;\n"
-   "varying vec2 tex_c2;\n"
-   "varying vec2 tex_c3;\n"
-   "#endif\n"
-   "#ifdef SHD_TEXA\n"
-   "uniform sampler2D texa;\n"
-   "varying vec2 tex_a;\n"
-   "#endif\n"
-   "#if defined(SHD_SAM12) || defined(SHD_SAM21) || defined(SHD_SAM22)\n"
-   "varying vec4 div_s;\n"
-   "# if defined(SHD_SAM12) || defined(SHD_SAM21)\n"
-   "varying vec2 tex_s[2];\n"
-   "# else\n"
-   "varying vec2 tex_s[4];\n"
-   "# endif\n"
-   "#endif\n"
-   "#ifdef SHD_MASK\n"
-   "uniform sampler2D texm;\n"
-   "varying vec2 tex_m;\n"
-   "# if defined(SHD_MASKSAM12) || defined(SHD_MASKSAM21)\n"
-   "varying float maskdiv_s;\n"
-   "varying vec2 masktex_s[2];\n"
-   "# elif defined(SHD_MASKSAM22)\n"
-   "varying float maskdiv_s;\n"
-   "varying vec2 masktex_s[4];\n"
-   "# endif\n"
-   "#endif\n"
-   "#ifdef SHD_ALPHA\n"
-   "# define SWZ aaaa\n"
-   "#else\n"
-   "# ifndef SHD_BGRA\n"
-   "#  if defined(SHD_IMG) && defined(SHD_BIGENDIAN)\n"
-   "#   define SWZ gbar\n"
-   "#  else\n"
-   "#   define SWZ bgra\n"
-   "#endif\n"
-   "# else\n"
-   "#  if defined(SHD_IMG) && defined(SHD_BIGENDIAN)\n"
-   "#   define SWZ grab\n"
-   "#  else\n"
-   "#   define SWZ rgba\n"
-   "#  endif\n"
-   "# endif\n"
-   "#endif\n"
-   "void main()\n"
-   "{\n"
-   "   vec4 c;\n"
-   "#if defined(SHD_YUV) || defined(SHD_NV12) || defined(SHD_YUY2)\n"
-   "   float r, g, b, y, u, v, vmu;\n"
-   "# if defined(SHD_YUV)\n"
-   "   y = texture2D(tex, tex_c).r;\n"
-   "   u = texture2D(texu, tex_c2).r;\n"
-   "   v = texture2D(texv, tex_c3).r;\n"
-   "# elif defined(SHD_NV12) || defined(SHD_YUY2)\n"
-   "   y = texture2D(tex, tex_c).g;\n"
-   "   u = texture2D(texuv, tex_c2).g;\n"
-   "   v = texture2D(texuv, tex_c2).a;\n"
-   "# endif\n"
-   "// center u and v around 0 for uv and y (with 128/255 for u + v, 16/255 for y)\n"
-   "   u = u - 0.5;\n"
-   "   v = v - 0.5;\n"
-   "# if defined (SHD_YUV_709)\n"
-   "// 709 yuv colorspace for hd content\n"
-   "   y = (y - 0.062) * 1.164;\n"
-   "   vmu = (v * 0.534) + (u * 0.213);\n"
-   "   v = v * 1.793;\n"
-   "   u = u * 2.115;\n"
-   "# else\n"
-   "// 601 colorspace constants (older yuv content)\n"
-   "   y = (y - 0.062) * 1.164;\n"
-   "   vmu = (v * 0.813) + (u * 0.391);\n"
-   "   v = v * 1.596;\n"
-   "   u = u * 2.018;\n"
-   "# endif\n"
-   "// common yuv\n"
-   "   r = y + v;\n"
-   "   g = y - vmu;\n"
-   "   b = y + u;\n"
-   "   c = vec4(r, g, b, 1.0);\n"
-   "#elif defined(SHD_SAM12) || defined(SHD_SAM21)\n"
-   "   vec4 col00 = texture2D(tex, tex_c + tex_s[0]).SWZ;\n"
-   "   vec4 col01 = texture2D(tex, tex_c + tex_s[1]).SWZ;\n"
-   "   c = (col00 + col01) / div_s;\n"
-   "#elif defined(SHD_SAM22)\n"
-   "   vec4 col00 = texture2D(tex, tex_c + tex_s[0]).SWZ;\n"
-   "   vec4 col01 = texture2D(tex, tex_c + tex_s[1]).SWZ;\n"
-   "   vec4 col10 = texture2D(tex, tex_c + tex_s[2]).SWZ;\n"
-   "   vec4 col11 = texture2D(tex, tex_c + tex_s[3]).SWZ;\n"
-   "   c = (col00 + col01 + col10 + col11) / div_s;\n"
-   "#elif defined(SHD_TEX) || defined(SHD_EXTERNAL)\n"
-   "   c = texture2D(tex, tex_c).SWZ;\n"
-   "#else\n"
-   "   c = vec4(1, 1, 1, 1);\n"
-   "#endif\n"
-   "#ifdef SHD_MASK\n"
-   "   float ma;\n"
-   "# if defined(SHD_MASKSAM12) || defined(SHD_MASKSAM21)\n"
-   "   float ma00 = texture2D(texm, tex_m + masktex_s[0]).a;\n"
-   "   float ma01 = texture2D(texm, tex_m + masktex_s[1]).a;\n"
-   "   ma = (ma00 + ma01) / maskdiv_s;\n"
-   "# elif defined(SHD_MASKSAM22)\n"
-   "   float ma00 = texture2D(texm, tex_m + masktex_s[0]).a;\n"
-   "   float ma01 = texture2D(texm, tex_m + masktex_s[1]).a;\n"
-   "   float ma10 = texture2D(texm, tex_m + masktex_s[2]).a;\n"
-   "   float ma11 = texture2D(texm, tex_m + masktex_s[3]).a;\n"
-   "   ma = (ma00 + ma01 + ma10 + ma11) / maskdiv_s;\n"
-   "# else\n"
-   "   ma = texture2D(texm, tex_m).a;\n"
-   "# endif\n"
-   "#endif\n"
-   "#ifdef SHD_AFILL\n"
-   "   c.a = 1.0;\n"
-   "#endif\n"
-   "   gl_FragColor =\n"
-   "       c\n"
-   "#ifndef SHD_NOMUL\n"
-   "     * col\n"
-   "#endif\n"
-   "#ifdef SHD_MASK\n"
-   "	 * ma\n"
-   "#endif\n"
-   "#ifdef SHD_TEXA\n"
-   "     * texture2D(texa, tex_a).r\n"
-   "#endif\n"
-   "   ;\n"
-   "}\n";
-
-static const char vertex_glsl[] =
-   "/* General-purpose vertex shader for all operations in Evas.\n"
-   " * This file can either be used directly by evas at runtime to\n"
-   " * generate its shaders with the appropriate #defines, or passed\n"
-   " * through cpp first (in which case the precision must be manually added).\n"
-   " */\n"
-   "#ifdef GL_ES\n"
-   "precision highp float;\n"
-   "#endif\n"
-   "attribute vec4 vertex;\n"
-   "uniform mat4 mvp;\n"
-   "/* All except nomul */\n"
-   "#ifndef SHD_NOMUL\n"
-   "attribute vec4 color;\n"
-   "varying vec4 col;\n"
-   "#endif\n"
-   "/* All images & fonts */\n"
-   "#if defined(SHD_TEX) || defined(SHD_EXTERNAL)\n"
-   "attribute vec2 tex_coord;\n"
-   "varying vec2 tex_c;\n"
-   "#endif\n"
-   "/* NV12, YUY2 */\n"
-   "#if defined(SHD_NV12) || defined(SHD_YUY2) || defined(SHD_YUV)\n"
-   "attribute vec2 tex_coord2;\n"
-   "varying vec2 tex_c2;\n"
-   "#endif\n"
-   "/* YUV */\n"
-   "#ifdef SHD_YUV\n"
-   "attribute vec2 tex_coord3;\n"
-   "varying vec2 tex_c3;\n"
-   "#endif\n"
-   "/* RGB+A */\n"
-   "#ifdef SHD_TEXA\n"
-   "attribute vec2 tex_coorda;\n"
-   "varying vec2 tex_a;\n"
-   "#endif\n"
-   "/* Sampling */\n"
-   "#if defined(SHD_SAM12) || defined(SHD_SAM21) || defined(SHD_SAM22)\n"
-   "attribute vec2 tex_sample;\n"
-   "varying vec4 div_s;\n"
-   "# if defined(SHD_SAM12) || defined(SHD_SAM21)\n"
-   "varying vec2 tex_s[2];\n"
-   "# else\n"
-   "varying vec2 tex_s[4];\n"
-   "# endif\n"
-   "#endif\n"
-   "/* Masking */\n"
-   "#ifdef SHD_MASK\n"
-   "attribute vec4 mask_coord;\n"
-   "varying vec2 tex_m;\n"
-   "# if defined(SHD_MASKSAM12) || defined(SHD_MASKSAM21)\n"
-   "attribute vec2 tex_masksample;\n"
-   "varying float maskdiv_s;\n"
-   "varying vec2 masktex_s[2];\n"
-   "# elif defined(SHD_MASKSAM22)\n"
-   "attribute vec2 tex_masksample;\n"
-   "varying float maskdiv_s;\n"
-   "varying vec2 masktex_s[4];\n"
-   "# endif\n"
-   "#endif\n"
-   "void main()\n"
-   "{\n"
-   "   gl_Position = mvp * vertex;\n"
-   "#ifndef SHD_NOMUL\n"
-   "   col = color;\n"
-   "#endif\n"
-   "#if defined(SHD_TEX) || defined(SHD_EXTERNAL)\n"
-   "   tex_c = tex_coord;\n"
-   "#endif\n"
-   "#ifdef SHD_NV12\n"
-   "   tex_c2 = tex_coord2 * 0.5;\n"
-   "#endif\n"
-   "#ifdef SHD_YUY2\n"
-   "   tex_c2 = vec2(tex_coord2.x * 0.5, tex_coord2.y);\n"
-   "#endif\n"
-   "#ifdef SHD_YUV\n"
-   "   tex_c2 = tex_coord2;\n"
-   "   tex_c3 = tex_coord3;\n"
-   "#endif\n"
-   "#ifdef SHD_TEXA\n"
-   "   tex_a = tex_coorda;\n"
-   "#endif\n"
-   "#if defined(SHD_SAM12)\n"
-   "   tex_s[0] = vec2(0, -tex_sample.y);\n"
-   "   tex_s[1] = vec2(0,  tex_sample.y);\n"
-   "   div_s = vec4(2, 2, 2, 2);\n"
-   "#elif defined(SHD_SAM21)\n"
-   "   tex_s[0] = vec2(-tex_sample.x, 0);\n"
-   "   tex_s[1] = vec2( tex_sample.x, 0);\n"
-   "   div_s = vec4(2, 2, 2, 2);\n"
-   "#elif defined(SHD_SAM22)\n"
-   "   tex_s[0] = vec2(-tex_sample.x, -tex_sample.y);\n"
-   "   tex_s[1] = vec2( tex_sample.x, -tex_sample.y);\n"
-   "   tex_s[2] = vec2( tex_sample.x,  tex_sample.y);\n"
-   "   tex_s[3] = vec2(-tex_sample.x,  tex_sample.y);\n"
-   "   div_s = vec4(4, 4, 4, 4);\n"
-   "#endif\n"
-   "#if defined(SHD_MASKSAM12)\n"
-   "   masktex_s[0] = vec2(0, -tex_masksample.y);\n"
-   "   masktex_s[1] = vec2(0,  tex_masksample.y);\n"
-   "   maskdiv_s = 2.0;\n"
-   "#elif defined(SHD_MASKSAM21)\n"
-   "   masktex_s[0] = vec2(-tex_masksample.x, 0);\n"
-   "   masktex_s[1] = vec2( tex_masksample.x, 0);\n"
-   "   maskdiv_s = 2.0;\n"
-   "#elif defined(SHD_MASKSAM22)\n"
-   "   masktex_s[0] = vec2(-tex_masksample.x, -tex_masksample.y);\n"
-   "   masktex_s[1] = vec2( tex_masksample.x, -tex_masksample.y);\n"
-   "   masktex_s[2] = vec2( tex_masksample.x,  tex_masksample.y);\n"
-   "   masktex_s[3] = vec2(-tex_masksample.x,  tex_masksample.y);\n"
-   "   maskdiv_s = 4.0;\n"
-   "#endif\n"
-   "#ifdef SHD_MASK\n"
-   "   // mask_coord.w contains the Y-invert flag\n"
-   "   // position on screen in [0..1] range of current pixel\n"
-   "   vec4 mask_Position = mvp * vertex * vec4(0.5, sign(mask_coord.w) * 0.5, 0.5, 0.5) + vec4(0.5, 0.5, 0, 0);\n"
-   "   tex_m = mask_Position.xy * abs(mask_coord.zw) + mask_coord.xy;\n"
-   "#endif\n"
-   "}\n";
-
--- a/src/modules/evas/engines/gl_common/shader_3d/evas_gl_3d_shaders.x
+++ /dev/null
@@ -1,2198 +0,0 @@
-/* DO NOT MODIFY THIS FILE AS IT IS AUTO-GENERATED */
-/* IF IT IS CHANGED PLEASE COMMIT THE CHANGES */
-
-static const char vertex_color_vert_glsl[] =
-   "#ifdef GL_ES\n"
-   "precision mediump float;\n"
-   "precision mediump int;\n"
-   "precision lowp sampler2D;\n"
-   "#endif\n"
-   "uniform     mat4  uMatrixMvp;\n"
-   "varying     vec4  vColor;\n"
-   "#ifdef VERTEX_POSITION\n"
-   "attribute   vec4  aPosition0;\n"
-   "#endif //VERTEX_POSITION\n"
-   "#ifdef VERTEX_POSITION_BLEND\n"
-   "attribute   vec4  aPosition1;\n"
-   "uniform     float uPositionWeight;\n"
-   "#endif //VERTEX_POSITION_BLEND\n"
-   "#ifdef VERTEX_COLOR\n"
-   "attribute   vec4  aColor0;\n"
-   "#endif //VERTEX_COLOR\n"
-   "#ifdef VERTEX_COLOR_BLEND\n"
-   "attribute   vec4  aColor1;\n"
-   "uniform     float uColorWeight;\n"
-   "#endif //VERTEX_COLOR_BLEND\n"
-   "void main()\n"
-   "{\n"
-   "   #ifdef VERTEX_POSITION_BLEND\n"
-   "   vec4 position = mix(aPosition1, aPosition0, uPositionWeight);\n"
-   "   position = vec4(position.xyz, 1.0);\n"
-   "#else\n"
-   "#ifdef VERTEX_POSITION\n"
-   "   vec4 position = vec4(aPosition0.xyz, 1.0);\n"
-   "#endif // VERTEX_POSITION\n"
-   "#endif //VERTEX_POSITION_BLEND\n"
-   "#ifdef VERTEX_COLOR_BLEND\n"
-   "   vec4 color = aColor0 * uColorWeight + aColor1 * (1.0 - uColorWeight);\n"
-   "#else\n"
-   "#ifdef VERTEX_COLOR\n"
-   "   vec4 color = aColor0;\n"
-   "#endif //VERTEX_COLOR\n"
-   "#endif //VERTEX_COLOR_BLEND\n"
-   "   vColor = color;\n"
-   "   gl_Position = uMatrixMvp * position;\n"
-   "}\n";
-
-static const char vertex_color_frag_glsl[] =
-   "#ifdef GL_ES\n"
-   "precision mediump float;\n"
-   "precision mediump int;\n"
-   "precision lowp sampler2D;\n"
-   "#endif\n"
-   "varying  vec4        vColor;\n"
-   "#ifdef FOG_ENABLED\n"
-   "uniform float uFogFactor;\n"
-   "uniform vec4  uFogColor;\n"
-   "#endif //FOG_ENABLED\n"
-   "uniform int   uAlphaTestComparison;\n"
-   "uniform float uAlphaTestRefValue;\n"
-   "void main()\n"
-   "{\n"
-   "#ifdef ALPHA_TEST_ENABLED\n"
-   "   /*uAlphaTestComparison is value of the Evas_3D_Comparison type*/\n"
-   "   const float p = 1000000.0;\n"
-   "   float acolor = floor(vColor.a * p);\n"
-   "   float refvalue = floor(uAlphaTestRefValue * p);\n"
-   "   if (uAlphaTestComparison == 0) discard;\n"
-   "   else if (uAlphaTestComparison == 1)\n"
-   "     {\n"
-   "        if (acolor < refvalue) gl_FragColor = vColor;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 2)\n"
-   "     {\n"
-   "        if (acolor == refvalue) gl_FragColor = vColor;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 3)\n"
-   "     {\n"
-   "        if (acolor <= refvalue) gl_FragColor = vColor;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 4)\n"
-   "     {\n"
-   "        if (acolor > refvalue) gl_FragColor = vColor;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 5)\n"
-   "     {\n"
-   "        if (acolor != refvalue) gl_FragColor = vColor;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 6)\n"
-   "     {\n"
-   "        if (acolor >= refvalue) gl_FragColor = vColor;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 7) ;\n"
-   "#else\n"
-   "   gl_FragColor = vColor;\n"
-   "#endif //ALPHA_TEST_ENABLED\n"
-   "   \n"
-   "#ifdef FOG_ENABLED\n"
-   "   float z = gl_FragCoord.z / gl_FragCoord.w;\n"
-   "   float fogFactor = exp2(-uFogFactor * uFogFactor * z * z * 1.44);\n"
-   "   fogFactor = clamp(fogFactor, 0.0, 1.0);\n"
-   "   gl_FragColor = mix(uFogColor, gl_FragColor, fogFactor);\n"
-   "#endif //FOG_ENABLED\n"
-   "}\n";
-
-static const char diffuse_vert_glsl[] =
-   "#ifdef GL_ES\n"
-   "precision mediump float;\n"
-   "precision mediump int;\n"
-   "precision lowp sampler2D;\n"
-   "#endif\n"
-   "uniform mat4  uMatrixMvp;\n"
-   "#ifdef VERTEX_POSITION\n"
-   "attribute   vec4  aPosition0;\n"
-   "#endif //VERTEX_POSITION\n"
-   "#ifdef VERTEX_POSITION_BLEND\n"
-   "attribute   vec4  aPosition1;\n"
-   "uniform     float uPositionWeight;\n"
-   "#endif //VERTEX_POSITION_BLEND\n"
-   "#ifdef VERTEX_TEXCOORD\n"
-   "attribute   vec4  aTexCoord0;\n"
-   "#endif //VERTEX_TEXCOORD\n"
-   "#ifdef VERTEX_TEXCOORD_BLEND\n"
-   "attribute   vec4  aTexCoord1;\n"
-   "uniform     float uTexCoordWeight;\n"
-   "#endif //VERTEX_TEXCOORD_BLEND\n"
-   "#ifdef NEED_TEX_COORD\n"
-   "varying vec2 vTexCoord;\n"
-   "#endif //NEED_TEX_COORD\n"
-   "void main()\n"
-   "{\n"
-   "   #ifdef VERTEX_POSITION_BLEND\n"
-   "   vec4 position = mix(aPosition1, aPosition0, uPositionWeight);\n"
-   "   position = vec4(position.xyz, 1.0);\n"
-   "#else\n"
-   "#ifdef VERTEX_POSITION\n"
-   "   vec4 position = vec4(aPosition0.xyz, 1.0);\n"
-   "#endif // VERTEX_POSITION\n"
-   "#endif //VERTEX_POSITION_BLEND\n"
-   "   #ifdef VERTEX_TEXCOORD_BLEND\n"
-   "   vTexCoord = mix(vec2(aTexCoord1.s, 1.0 - aTexCoord1.t),\n"
-   "                   vec2(aTexCoord0.s, 1.0 - aTexCoord0.t), uTexCoordWeight);\n"
-   "#else\n"
-   "#ifdef VERTEX_TEXCOORD\n"
-   "   vTexCoord = vec2(aTexCoord0.s, 1.0 - aTexCoord0.t);\n"
-   "#endif //VERTEX_TEXCOORD\n"
-   "#endif //VERTEX_TEXCOORD_BLEND\n"
-   "   gl_Position = uMatrixMvp * position;\n"
-   "}\n";
-
-static const char diffuse_frag_glsl[] =
-   "#ifdef GL_ES\n"
-   "precision mediump float;\n"
-   "precision mediump int;\n"
-   "precision lowp sampler2D;\n"
-   "#endif\n"
-   "#ifdef NEED_TEX_COORD\n"
-   "varying vec2   vTexCoord;\n"
-   "#endif //TEX_COORD\n"
-   "#ifdef FOG_ENABLED\n"
-   "uniform float uFogFactor;\n"
-   "uniform vec4  uFogColor;\n"
-   "#endif //FOG_ENABLED\n"
-   "#ifdef DIFFUSE\n"
-   "uniform   vec4        uMaterialDiffuse;\n"
-   "uniform   vec4        uLightDiffuse;\n"
-   "#ifdef DIFFUSE_TEXTURE\n"
-   "uniform sampler2D  uTextureDiffuse0;\n"
-   "uniform mat3 uTextureMatrixTransformDiffuse0;\n"
-   "#endif //DIFFUSE_TEXTURE\n"
-   "#ifdef DIFFUSE_TEXTURE_BLEND\n"
-   "uniform sampler2D  uTextureDiffuse1;\n"
-   "uniform float      uTextureDiffuseWeight;\n"
-   "uniform mat3 uTextureMatrixTransformDiffuse1;\n"
-   "#endif //DIFFUSE_TEXTURE_BLEND\n"
-   "#endif //DIFFUSE\n"
-   "uniform int   uAlphaTestComparison;\n"
-   "uniform float uAlphaTestRefValue;\n"
-   "void main() {\n"
-   "   vec4  color;\n"
-   "   \n"
-   "#ifdef  DIFFUSE_TEXTURE_BLEND\n"
-   "   vec3 Tex0CoordDiffuse = vec3(vTexCoord, 1.0) * uTextureMatrixTransformDiffuse0;\n"
-   "   vec3 Tex1CoordDiffuse = vec3(vTexCoord, 1.0) * uTextureMatrixTransformDiffuse1;\n"
-   "   color = mix(texture2D(uTextureDiffuse1, vec2(Tex1CoordDiffuse)),\n"
-   "               texture2D(uTextureDiffuse0, vec2(Tex0CoordDiffuse)), uTextureDiffuseWeight);\n"
-   "   color *= uMaterialDiffuse;\n"
-   "#else\n"
-   "#ifdef  DIFFUSE_TEXTURE\n"
-   "   vec3 Tex0CoordDiffuse = vec3(vTexCoord, 1.0) * uTextureMatrixTransformDiffuse0;\n"
-   "   color = texture2D(uTextureDiffuse0, vec2(Tex0CoordDiffuse)) * uMaterialDiffuse;\n"
-   "#else\n"
-   "   color = uMaterialDiffuse;\n"
-   "#endif //DIFFUSE_TEXTURE\n"
-   "#endif //DIFFUSE_TEXTURE_BLEND\n"
-   "#ifdef ALPHA_TEST_ENABLED\n"
-   "   /*uAlphaTestComparison is value of the Evas_3D_Comparison type*/\n"
-   "   const float p = 1000000.0;\n"
-   "   float acolor = floor(color.a * p);\n"
-   "   float refvalue = floor(uAlphaTestRefValue * p);\n"
-   "   if (uAlphaTestComparison == 0) discard;\n"
-   "   else if (uAlphaTestComparison == 1)\n"
-   "     {\n"
-   "        if (acolor < refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 2)\n"
-   "     {\n"
-   "        if (acolor == refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 3)\n"
-   "     {\n"
-   "        if (acolor <= refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 4)\n"
-   "     {\n"
-   "        if (acolor > refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 5)\n"
-   "     {\n"
-   "        if (acolor != refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 6)\n"
-   "     {\n"
-   "        if (acolor >= refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 7) ;\n"
-   "#else\n"
-   "   gl_FragColor = color;\n"
-   "#endif //ALPHA_TEST_ENABLED\n"
-   "   \n"
-   "#ifdef FOG_ENABLED\n"
-   "   float z = gl_FragCoord.z / gl_FragCoord.w;\n"
-   "   float fogFactor = exp2(-uFogFactor * uFogFactor * z * z * 1.44);\n"
-   "   fogFactor = clamp(fogFactor, 0.0, 1.0);\n"
-   "   gl_FragColor = mix(uFogColor, gl_FragColor, fogFactor);\n"
-   "#endif //FOG_ENABLED\n"
-   "}\n";
-
-static const char flat_vert_glsl[] =
-   "#ifdef GL_ES\n"
-   "precision mediump float;\n"
-   "precision mediump int;\n"
-   "precision lowp sampler2D;\n"
-   "#endif\n"
-   "uniform   mat4  uMatrixMvp;\n"
-   "uniform   mat3  uMatrixNormal;\n"
-   "uniform   mat4  uMatrixModelview;\n"
-   "uniform   vec4  uLightPosition;\n"
-   "varying   vec2  vFactor;\n"
-   "#ifdef SHADOWED\n"
-   "uniform mat4 uMatrixLight;\n"
-   "varying vec4 vLightPosition;\n"
-   "#endif //SHADOWED\n"
-   "#ifdef VERTEX_POSITION\n"
-   "attribute   vec4  aPosition0;\n"
-   "#endif //VERTEX_POSITION\n"
-   "#ifdef VERTEX_POSITION_BLEND\n"
-   "attribute   vec4  aPosition1;\n"
-   "uniform     float uPositionWeight;\n"
-   "#endif //VERTEX_POSITION_BLEND\n"
-   "#ifdef VERTEX_NORMAL\n"
-   "attribute   vec4  aNormal0;\n"
-   "#endif //VERTEX_NORMAL\n"
-   "#ifdef VERTEX_NORMAL_BLEND\n"
-   "attribute   vec4  aNormal1;\n"
-   "uniform     float uNormalWeight;\n"
-   "#endif //VERTEX_NORMAL_BLEND\n"
-   "#ifdef VERTEX_TEXCOORD\n"
-   "attribute   vec4  aTexCoord0;\n"
-   "#endif //VERTEX_TEXCOORD\n"
-   "#ifdef VERTEX_TEXCOORD_BLEND\n"
-   "attribute   vec4  aTexCoord1;\n"
-   "uniform     float uTexCoordWeight;\n"
-   "#endif //VERTEX_TEXCOORD_BLEND\n"
-   "#ifdef NEED_TEX_COORD\n"
-   "varying vec2 vTexCoord;\n"
-   "#endif //NEED_TEX_COORD\n"
-   "#ifdef LIGHT_SPOT\n"
-   "uniform   vec3  uLightSpotDir;\n"
-   "uniform   float uLightSpotExp;\n"
-   "uniform   float uLightSpotCutoffCos;\n"
-   "#endif //LIGHT_SPOT\n"
-   "#ifdef SPECULAR\n"
-   "uniform float   uMaterialShininess;\n"
-   "#endif //SPECULAR\n"
-   "#ifdef LIGHT_ATTENUATION\n"
-   "uniform   vec3  uLightAtten;\n"
-   "#endif //LIGHT_ATTENUATION\n"
-   "void vertexFlat(vec4 position, vec3 normal)\n"
-   "{\n"
-   "   vec3  lv;\n"
-   "   float factor;\n"
-   "   normal = uMatrixNormal * normal;\n"
-   "   position = uMatrixModelview * position;\n"
-   "#ifdef NORMALIZE_NORMALS\n"
-   "   normal = normalize(normal);\n"
-   "#endif //NORMALIZE_NORMALS\n"
-   "#ifdef LIGHT_DIRECTIONAL\n"
-   "   lv = uLightPosition.xyz;\n"
-   "#else\n"
-   "   lv = uLightPosition.xyz - position.xyz;\n"
-   "   lv = normalize(lv);\n"
-   "#endif //LIGHT_DIRECTIONAL\n"
-   "   factor = max(dot(lv, normal), 0.0);\n"
-   "#ifdef LIGHT_SPOT\n"
-   "   float f = dot(-lv, uLightSpotDir);\n"
-   "   if (f > uLightSpotCutoffCos)\n"
-   "     factor *= pow(f, uLightSpotExp);\n"
-   "   else\n"
-   "      factor = 0.0;\n"
-   "#endif //LIGHT_SPOT\n"
-   "   if (factor > 0.0)\n"
-   "     {\n"
-   "#ifdef DIFFUSE\n"
-   "        vFactor.x = factor;\n"
-   "#else\n"
-   "        vFactor.x = 0.0;\n"
-   "#endif //DIFFUSE\n"
-   "#ifdef SPECULAR\n"
-   "        vec3  hv = normalize(normalize(-position.xyz) + lv);\n"
-   "        factor = pow(max(dot(hv, normal), 0.0), uMaterialShininess);\n"
-   "        vFactor.y = factor;\n"
-   "#endif //SPECULAR\n"
-   "     }\n"
-   "   else\n"
-   "     vFactor = vec2(0.0, 0.0);\n"
-   "   /* Light attenuation. */\n"
-   "#ifdef LIGHT_ATTENUATION\n"
-   "   float dist = length(lv);\n"
-   "   vFactor /= dot(uLightAtten, vec3(1.0, dist, dist * dist));\n"
-   "#endif //LIGHT_ATTENUATION\n"
-   "}\n"
-   "void main()\n"
-   "{\n"
-   "   #ifdef VERTEX_POSITION_BLEND\n"
-   "   vec4 position = mix(aPosition1, aPosition0, uPositionWeight);\n"
-   "   position = vec4(position.xyz, 1.0);\n"
-   "#else\n"
-   "#ifdef VERTEX_POSITION\n"
-   "   vec4 position = vec4(aPosition0.xyz, 1.0);\n"
-   "#endif // VERTEX_POSITION\n"
-   "#endif //VERTEX_POSITION_BLEND\n"
-   "   #ifdef VERTEX_NORMAL_BLEND\n"
-   "   vec3 normal = mix(aNormal1.xyz, aNormal0.xyz, uNormalWeight);\n"
-   "#else\n"
-   "#ifdef VERTEX_NORMAL\n"
-   "   vec3 normal = aNormal0.xyz;\n"
-   "#endif //VERTEX_NORMAL\n"
-   "#endif //VERTEX_NORMAL_BLEND\n"
-   "   #ifdef VERTEX_TEXCOORD_BLEND\n"
-   "   vTexCoord = mix(vec2(aTexCoord1.s, 1.0 - aTexCoord1.t),\n"
-   "                   vec2(aTexCoord0.s, 1.0 - aTexCoord0.t), uTexCoordWeight);\n"
-   "#else\n"
-   "#ifdef VERTEX_TEXCOORD\n"
-   "   vTexCoord = vec2(aTexCoord0.s, 1.0 - aTexCoord0.t);\n"
-   "#endif //VERTEX_TEXCOORD\n"
-   "#endif //VERTEX_TEXCOORD_BLEND\n"
-   "   gl_Position = uMatrixMvp * position;\n"
-   "   vertexFlat(position, normal);\n"
-   "   #ifdef SHADOWED\n"
-   "   vLightPosition = uMatrixLight * position;\n"
-   "#endif //SHADOWED\n"
-   "}\n";
-
-static const char flat_frag_glsl[] =
-   "#ifdef GL_ES\n"
-   "precision mediump float;\n"
-   "precision mediump int;\n"
-   "precision lowp sampler2D;\n"
-   "#endif\n"
-   "varying vec2   vFactor;\n"
-   "#ifdef NEED_TEX_COORD\n"
-   "varying vec2   vTexCoord;\n"
-   "#endif //TEX_COORD\n"
-   "#ifdef FOG_ENABLED\n"
-   "uniform float uFogFactor;\n"
-   "uniform vec4  uFogColor;\n"
-   "#endif //FOG_ENABLED\n"
-   "#ifdef  SHADOWED\n"
-   "varying vec4 vLightPosition;\n"
-   "uniform sampler2D uShadowMap;\n"
-   "uniform float uShadowsPCFStep;\n"
-   "uniform float uShadowsPCFSize;\n"
-   "uniform float uShadowsConstantBias;\n"
-   "float shadow;\n"
-   "float pcf(vec4 lpos)\n"
-   "{\n"
-   "   vec3 smcoord = lpos.xyz / lpos.w * 0.5 + 0.5;\n"
-   "   float i, j, shadow, q, c;\n"
-   "   q = floor(uShadowsPCFStep * 2.0);\n"
-   "   c = floor(uShadowsPCFStep * uShadowsPCFStep * 4.0);\n"
-   "   shadow = 0.0;\n"
-   "   const vec4 unpack = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n"
-   "   for (i = -uShadowsPCFStep; i < uShadowsPCFStep; i += 1.0)\n"
-   "     for (j = -uShadowsPCFStep; j < uShadowsPCFStep; j += 1.0)\n"
-   "       {\n"
-   "          vec4 zvalue = texture2D(uShadowMap, smcoord.xy + vec2(i / q, j / q) * uShadowsPCFSize);\n"
-   "          shadow += float(smcoord.z < dot(zvalue, unpack) + uShadowsConstantBias);\n"
-   "       }\n"
-   "   return shadow / c;\n"
-   "}\n"
-   "#endif //SHADOWED\n"
-   "#ifdef DIFFUSE\n"
-   "uniform   vec4        uMaterialDiffuse;\n"
-   "uniform   vec4        uLightDiffuse;\n"
-   "#ifdef DIFFUSE_TEXTURE\n"
-   "uniform sampler2D  uTextureDiffuse0;\n"
-   "uniform mat3 uTextureMatrixTransformDiffuse0;\n"
-   "#endif //DIFFUSE_TEXTURE\n"
-   "#ifdef DIFFUSE_TEXTURE_BLEND\n"
-   "uniform sampler2D  uTextureDiffuse1;\n"
-   "uniform float      uTextureDiffuseWeight;\n"
-   "uniform mat3 uTextureMatrixTransformDiffuse1;\n"
-   "#endif //DIFFUSE_TEXTURE_BLEND\n"
-   "#endif //DIFFUSE\n"
-   "#ifdef SPECULAR\n"
-   "uniform   vec4     uLightSpecular;\n"
-   "uniform   float    uMaterialShininess;\n"
-   "uniform   vec4     uMaterialSpecular;\n"
-   "#ifdef SPECULAR_TEXTURE\n"
-   "uniform sampler2D  uTextureSpecular0;\n"
-   "uniform mat3 uTextureMatrixTransformSpecular0;\n"
-   "#endif //SPECULAR_TEXTURE\n"
-   "#ifdef SPECULAR_TEXTURE_BLEND\n"
-   "uniform sampler2D  uTextureSpecular1;\n"
-   "uniform float      uTextureSpecularWeight;\n"
-   "uniform mat3 uTextureMatrixTransformSpecular1;\n"
-   "#endif //SPECULAR_TEXTURE_BLEND\n"
-   "#endif //SPECULAR\n"
-   "#ifdef AMBIENT\n"
-   "uniform  vec4       uMaterialAmbient;\n"
-   "uniform  vec4       uLightAmbient;\n"
-   "#ifdef AMBIENT_TEXTURE\n"
-   "uniform sampler2D  uTextureAmbient0;\n"
-   "uniform mat3 uTextureMatrixTransformAmbient0;\n"
-   "#endif //AMBIENT_TEXTURE\n"
-   "#ifdef AMBIENT_TEXTURE_BLEND\n"
-   "uniform sampler2D  uTextureAmbient1;\n"
-   "uniform float      uTextureAmbientWeight;\n"
-   "uniform mat3 uTextureMatrixTransformAmbient1;\n"
-   "#endif //AMBIENT_TEXTURE_BLEND\n"
-   "#endif //AMBIENT\n"
-   "#ifdef EMISSION\n"
-   "uniform vec4       uMaterialEmission;\n"
-   "#ifdef EMISSION_TEXTURE\n"
-   "uniform sampler2D  uTextureEmission0;\n"
-   "uniform mat3 uTextureMatrixTransformEmission0;\n"
-   "#endif //EMISSION_TEXTURE\n"
-   "#ifdef EMISSION_TEXTURE_BLEND\n"
-   "uniform sampler2D  uTextureEmission1;\n"
-   "uniform float      uTextureEmissionWeight;\n"
-   "uniform mat3 uTextureMatrixTransformEmission1;\n"
-   "#endif //EMISSION_TEXTURE_BLEND\n"
-   "#endif //EMISSION\n"
-   "uniform int   uAlphaTestComparison;\n"
-   "uniform float uAlphaTestRefValue;\n"
-   "vec4 fragmentFlat()\n"
-   "{\n"
-   "   vec4 color;\n"
-   "   vec4 fragcolor;\n"
-   "#ifdef DIFFUSE\n"
-   "   \n"
-   "#ifdef  DIFFUSE_TEXTURE_BLEND\n"
-   "   vec3 Tex0CoordDiffuse = vec3(vTexCoord, 1.0) * uTextureMatrixTransformDiffuse0;\n"
-   "   vec3 Tex1CoordDiffuse = vec3(vTexCoord, 1.0) * uTextureMatrixTransformDiffuse1;\n"
-   "   color = mix(texture2D(uTextureDiffuse1, vec2(Tex1CoordDiffuse)),\n"
-   "               texture2D(uTextureDiffuse0, vec2(Tex0CoordDiffuse)), uTextureDiffuseWeight);\n"
-   "   color *= uMaterialDiffuse;\n"
-   "#else\n"
-   "#ifdef  DIFFUSE_TEXTURE\n"
-   "   vec3 Tex0CoordDiffuse = vec3(vTexCoord, 1.0) * uTextureMatrixTransformDiffuse0;\n"
-   "   color = texture2D(uTextureDiffuse0, vec2(Tex0CoordDiffuse)) * uMaterialDiffuse;\n"
-   "#else\n"
-   "   color = uMaterialDiffuse;\n"
-   "#endif //DIFFUSE_TEXTURE\n"
-   "#endif //DIFFUSE_TEXTURE_BLEND\n"
-   "   fragcolor = uLightDiffuse * color * vFactor.x;\n"
-   "#else\n"
-   "   fragcolor = vec4(0.0, 0.0, 0.0, 0.0);\n"
-   "#endif //DIFFUSE\n"
-   "#ifdef SPECULAR\n"
-   "   \n"
-   "#ifdef  SPECULAR_TEXTURE_BLEND\n"
-   "   vec3 Tex0CoordSpecular = vec3(vTexCoord, 1.0) * uTextureMatrixTransformSpecular0;\n"
-   "   vec3 Tex1CoordSpecular = vec3(vTexCoord, 1.0) * uTextureMatrixTransformSpecular1;\n"
-   "   color = mix(texture2D(uTextureSpecular1, vec2(Tex1CoordSpecular)),\n"
-   "               texture2D(uTextureSpecular0, vec2(Tex0CoordSpecular)), uTextureSpecularWeight);\n"
-   "   color *= uMaterialSpecular;\n"
-   "#else\n"
-   "#ifdef  SPECULAR_TEXTURE\n"
-   "   vec3 Tex0CoordSpecular = vec3(vTexCoord, 1.0) * uTextureMatrixTransformSpecular0;\n"
-   "   color = texture2D(uTextureSpecular0, vec2(Tex0CoordSpecular)) * uMaterialSpecular;\n"
-   "#else\n"
-   "   color = uMaterialSpecular;\n"
-   "#endif //SPECULAR_TEXTURE\n"
-   "#endif //SPECULAR_TEXTURE_BLEND\n"
-   "   fragcolor += uLightSpecular * color * vFactor.y;\n"
-   "#endif //SPECULAR\n"
-   "#ifdef SHADOWED\n"
-   "   fragcolor *= shadow;\n"
-   "#endif //SHADOWED\n"
-   "#ifdef AMBIENT\n"
-   "   \n"
-   "#ifdef  AMBIENT_TEXTURE_BLEND\n"
-   "   vec3 Tex0CoordAmbient = vec3(vTexCoord, 1.0) * uTextureMatrixTransformAmbient0;\n"
-   "   vec3 Tex1CoordAmbient = vec3(vTexCoord, 1.0) * uTextureMatrixTransformAmbient1;\n"
-   "   color = mix(texture2D(uTextureAmbient1, vec2(Tex1CoordAmbient)),\n"
-   "               texture2D(uTextureAmbient0, vec2(Tex0CoordAmbient)), uTextureAmbientWeight);\n"
-   "   color *= uMaterialAmbient;\n"
-   "#else\n"
-   "#ifdef  AMBIENT_TEXTURE\n"
-   "   vec3 Tex0CoordAmbient = vec3(vTexCoord, 1.0) * uTextureMatrixTransformAmbient0;\n"
-   "   color = texture2D(uTextureAmbient0, vec2(Tex0CoordAmbient)) * uMaterialAmbient;\n"
-   "#else\n"
-   "   color = uMaterialAmbient;\n"
-   "#endif //AMBIENT_TEXTURE\n"
-   "#endif //AMBIENT_TEXTURE_BLEND\n"
-   "   fragcolor += uLightAmbient * color;\n"
-   "#endif //AMBIENT\n"
-   "#ifdef  EMISSION\n"
-   "   \n"
-   "#ifdef  EMISSION_TEXTURE_BLEND\n"
-   "   vec3 Tex0CoordEmission = vec3(vTexCoord, 1.0) * uTextureMatrixTransformEmission0;\n"
-   "   vec3 Tex1CoordEmission = vec3(vTexCoord, 1.0) * uTextureMatrixTransformEmission1;\n"
-   "   color = mix(texture2D(uTextureEmission1, vec2(Tex1CoordEmission)),\n"
-   "               texture2D(uTextureEmission0, vec2(Tex0CoordEmission)), uTextureEmissionWeight);\n"
-   "   color *= uMaterialEmission;\n"
-   "#else\n"
-   "#ifdef  EMISSION_TEXTURE\n"
-   "   vec3 Tex0CoordEmission = vec3(vTexCoord, 1.0) * uTextureMatrixTransformEmission0;\n"
-   "   color = texture2D(uTextureEmission0, vec2(Tex0CoordEmission)) * uMaterialEmission;\n"
-   "#else\n"
-   "   color = uMaterialEmission;\n"
-   "#endif //EMISSION_TEXTURE\n"
-   "#endif //EMISSION_TEXTURE_BLEND\n"
-   "   fragcolor += color;\n"
-   "#endif //EMISSION\n"
-   "   return fragcolor;\n"
-   "}\n"
-   "void main() {\n"
-   "   vec4 color;\n"
-   "#ifdef SHADOWED\n"
-   "   shadow = pcf(vLightPosition);\n"
-   "#endif //SHADOWED\n"
-   "   color = fragmentFlat();\n"
-   "#ifdef ALPHA_TEST_ENABLED\n"
-   "   /*uAlphaTestComparison is value of the Evas_3D_Comparison type*/\n"
-   "   const float p = 1000000.0;\n"
-   "   float acolor = floor(color.a * p);\n"
-   "   float refvalue = floor(uAlphaTestRefValue * p);\n"
-   "   if (uAlphaTestComparison == 0) discard;\n"
-   "   else if (uAlphaTestComparison == 1)\n"
-   "     {\n"
-   "        if (acolor < refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 2)\n"
-   "     {\n"
-   "        if (acolor == refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 3)\n"
-   "     {\n"
-   "        if (acolor <= refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 4)\n"
-   "     {\n"
-   "        if (acolor > refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 5)\n"
-   "     {\n"
-   "        if (acolor != refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 6)\n"
-   "     {\n"
-   "        if (acolor >= refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 7) ;\n"
-   "#else\n"
-   "   gl_FragColor = color;\n"
-   "#endif //ALPHA_TEST_ENABLED\n"
-   "   \n"
-   "#ifdef FOG_ENABLED\n"
-   "   float z = gl_FragCoord.z / gl_FragCoord.w;\n"
-   "   float fogFactor = exp2(-uFogFactor * uFogFactor * z * z * 1.44);\n"
-   "   fogFactor = clamp(fogFactor, 0.0, 1.0);\n"
-   "   gl_FragColor = mix(uFogColor, gl_FragColor, fogFactor);\n"
-   "#endif //FOG_ENABLED\n"
-   "}\n";
-
-static const char phong_vert_glsl[] =
-   "#ifdef GL_ES\n"
-   "precision mediump float;\n"
-   "precision mediump int;\n"
-   "precision lowp sampler2D;\n"
-   "#endif\n"
-   "uniform  mat4  uMatrixMvp;\n"
-   "uniform  mat3  uMatrixNormal;\n"
-   "uniform  mat4  uMatrixModelview;\n"
-   "uniform  vec4  uLightPosition;\n"
-   "varying  vec3  vLightVector;\n"
-   "varying  vec3  vLightHalfVector;\n"
-   "varying  vec3  vNormal;\n"
-   "#ifdef SHADOWED\n"
-   "uniform mat4 uMatrixLight;\n"
-   "varying vec4 vLightPosition;\n"
-   "#endif //SHADOWED\n"
-   "#ifdef VERTEX_POSITION\n"
-   "attribute   vec4  aPosition0;\n"
-   "#endif //VERTEX_POSITION\n"
-   "#ifdef VERTEX_POSITION_BLEND\n"
-   "attribute   vec4  aPosition1;\n"
-   "uniform     float uPositionWeight;\n"
-   "#endif //VERTEX_POSITION_BLEND\n"
-   "#ifdef VERTEX_NORMAL\n"
-   "attribute   vec4  aNormal0;\n"
-   "#endif //VERTEX_NORMAL\n"
-   "#ifdef VERTEX_NORMAL_BLEND\n"
-   "attribute   vec4  aNormal1;\n"
-   "uniform     float uNormalWeight;\n"
-   "#endif //VERTEX_NORMAL_BLEND\n"
-   "#ifdef VERTEX_TEXCOORD\n"
-   "attribute   vec4  aTexCoord0;\n"
-   "#endif //VERTEX_TEXCOORD\n"
-   "#ifdef VERTEX_TEXCOORD_BLEND\n"
-   "attribute   vec4  aTexCoord1;\n"
-   "uniform     float uTexCoordWeight;\n"
-   "#endif //VERTEX_TEXCOORD_BLEND\n"
-   "#ifdef NEED_TEX_COORD\n"
-   "varying vec2 vTexCoord;\n"
-   "#endif //NEED_TEX_COORD\n"
-   "#ifdef LIGHT_ATTENUATION\n"
-   "varying  float vLightDist;\n"
-   "#endif //LIGHT_ATTENUATION\n"
-   "void vertexPhong(vec4 position, vec3 normal)\n"
-   "{\n"
-   "   normal = uMatrixNormal * normal;\n"
-   "   position = uMatrixModelview * position;\n"
-   "#ifdef NORMALIZE_NORMALS\n"
-   "   normal = normalize(normal);\n"
-   "#endif //NORMALIZE_NORMALS\n"
-   "#ifdef LIGHT_DIRECTIONAL\n"
-   "   vLightVector = uLightPosition.xyz;\n"
-   "#else\n"
-   "   vLightVector = uLightPosition.xyz - position.xyz;\n"
-   "#ifdef LIGHT_ATTENUATION\n"
-   "   vLightDist = length(vLightVector);\n"
-   "#endif //LIGHT_ATTENUATION\n"
-   "   vLightVector = normalize(vLightVector);\n"
-   "#endif //LIGHT_DIRECTIONAL\n"
-   "   vLightHalfVector = normalize(normalize(-position.xyz) + vLightVector);\n"
-   "   vNormal = normal;\n"
-   "}\n"
-   "void main() {\n"
-   "   #ifdef VERTEX_POSITION_BLEND\n"
-   "   vec4 position = mix(aPosition1, aPosition0, uPositionWeight);\n"
-   "   position = vec4(position.xyz, 1.0);\n"
-   "#else\n"
-   "#ifdef VERTEX_POSITION\n"
-   "   vec4 position = vec4(aPosition0.xyz, 1.0);\n"
-   "#endif // VERTEX_POSITION\n"
-   "#endif //VERTEX_POSITION_BLEND\n"
-   "   #ifdef VERTEX_NORMAL_BLEND\n"
-   "   vec3 normal = mix(aNormal1.xyz, aNormal0.xyz, uNormalWeight);\n"
-   "#else\n"
-   "#ifdef VERTEX_NORMAL\n"
-   "   vec3 normal = aNormal0.xyz;\n"
-   "#endif //VERTEX_NORMAL\n"
-   "#endif //VERTEX_NORMAL_BLEND\n"
-   "   #ifdef VERTEX_TEXCOORD_BLEND\n"
-   "   vTexCoord = mix(vec2(aTexCoord1.s, 1.0 - aTexCoord1.t),\n"
-   "                   vec2(aTexCoord0.s, 1.0 - aTexCoord0.t), uTexCoordWeight);\n"
-   "#else\n"
-   "#ifdef VERTEX_TEXCOORD\n"
-   "   vTexCoord = vec2(aTexCoord0.s, 1.0 - aTexCoord0.t);\n"
-   "#endif //VERTEX_TEXCOORD\n"
-   "#endif //VERTEX_TEXCOORD_BLEND\n"
-   "   gl_Position = uMatrixMvp * position;\n"
-   "   vertexPhong(position, normal);\n"
-   "   #ifdef SHADOWED\n"
-   "   vLightPosition = uMatrixLight * position;\n"
-   "#endif //SHADOWED\n"
-   "}\n";
-
-static const char phong_frag_glsl[] =
-   "#ifdef GL_ES\n"
-   "precision mediump float;\n"
-   "precision mediump int;\n"
-   "precision lowp sampler2D;\n"
-   "#endif\n"
-   "varying  vec3        vLightVector;\n"
-   "varying  vec3        vLightHalfVector;\n"
-   "varying  vec3        vNormal;\n"
-   "#ifdef NEED_TEX_COORD\n"
-   "varying vec2   vTexCoord;\n"
-   "#endif //TEX_COORD\n"
-   "#ifdef FOG_ENABLED\n"
-   "uniform float uFogFactor;\n"
-   "uniform vec4  uFogColor;\n"
-   "#endif //FOG_ENABLED\n"
-   "#ifdef  SHADOWED\n"
-   "varying vec4 vLightPosition;\n"
-   "uniform sampler2D uShadowMap;\n"
-   "uniform float uShadowsPCFStep;\n"
-   "uniform float uShadowsPCFSize;\n"
-   "uniform float uShadowsConstantBias;\n"
-   "float shadow;\n"
-   "float pcf(vec4 lpos)\n"
-   "{\n"
-   "   vec3 smcoord = lpos.xyz / lpos.w * 0.5 + 0.5;\n"
-   "   float i, j, shadow, q, c;\n"
-   "   q = floor(uShadowsPCFStep * 2.0);\n"
-   "   c = floor(uShadowsPCFStep * uShadowsPCFStep * 4.0);\n"
-   "   shadow = 0.0;\n"
-   "   const vec4 unpack = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n"
-   "   for (i = -uShadowsPCFStep; i < uShadowsPCFStep; i += 1.0)\n"
-   "     for (j = -uShadowsPCFStep; j < uShadowsPCFStep; j += 1.0)\n"
-   "       {\n"
-   "          vec4 zvalue = texture2D(uShadowMap, smcoord.xy + vec2(i / q, j / q) * uShadowsPCFSize);\n"
-   "          shadow += float(smcoord.z < dot(zvalue, unpack) + uShadowsConstantBias);\n"
-   "       }\n"
-   "   return shadow / c;\n"
-   "}\n"
-   "#endif //SHADOWED\n"
-   "#ifdef DIFFUSE\n"
-   "uniform   vec4        uMaterialDiffuse;\n"
-   "uniform   vec4        uLightDiffuse;\n"
-   "#ifdef DIFFUSE_TEXTURE\n"
-   "uniform sampler2D  uTextureDiffuse0;\n"
-   "uniform mat3 uTextureMatrixTransformDiffuse0;\n"
-   "#endif //DIFFUSE_TEXTURE\n"
-   "#ifdef DIFFUSE_TEXTURE_BLEND\n"
-   "uniform sampler2D  uTextureDiffuse1;\n"
-   "uniform float      uTextureDiffuseWeight;\n"
-   "uniform mat3 uTextureMatrixTransformDiffuse1;\n"
-   "#endif //DIFFUSE_TEXTURE_BLEND\n"
-   "#endif //DIFFUSE\n"
-   "#ifdef SPECULAR\n"
-   "uniform   vec4     uLightSpecular;\n"
-   "uniform   float    uMaterialShininess;\n"
-   "uniform   vec4     uMaterialSpecular;\n"
-   "#ifdef SPECULAR_TEXTURE\n"
-   "uniform sampler2D  uTextureSpecular0;\n"
-   "uniform mat3 uTextureMatrixTransformSpecular0;\n"
-   "#endif //SPECULAR_TEXTURE\n"
-   "#ifdef SPECULAR_TEXTURE_BLEND\n"
-   "uniform sampler2D  uTextureSpecular1;\n"
-   "uniform float      uTextureSpecularWeight;\n"
-   "uniform mat3 uTextureMatrixTransformSpecular1;\n"
-   "#endif //SPECULAR_TEXTURE_BLEND\n"
-   "#endif //SPECULAR\n"
-   "#ifdef AMBIENT\n"
-   "uniform  vec4       uMaterialAmbient;\n"
-   "uniform  vec4       uLightAmbient;\n"
-   "#ifdef AMBIENT_TEXTURE\n"
-   "uniform sampler2D  uTextureAmbient0;\n"
-   "uniform mat3 uTextureMatrixTransformAmbient0;\n"
-   "#endif //AMBIENT_TEXTURE\n"
-   "#ifdef AMBIENT_TEXTURE_BLEND\n"
-   "uniform sampler2D  uTextureAmbient1;\n"
-   "uniform float      uTextureAmbientWeight;\n"
-   "uniform mat3 uTextureMatrixTransformAmbient1;\n"
-   "#endif //AMBIENT_TEXTURE_BLEND\n"
-   "#endif //AMBIENT\n"
-   "#ifdef EMISSION\n"
-   "uniform vec4       uMaterialEmission;\n"
-   "#ifdef EMISSION_TEXTURE\n"
-   "uniform sampler2D  uTextureEmission0;\n"
-   "uniform mat3 uTextureMatrixTransformEmission0;\n"
-   "#endif //EMISSION_TEXTURE\n"
-   "#ifdef EMISSION_TEXTURE_BLEND\n"
-   "uniform sampler2D  uTextureEmission1;\n"
-   "uniform float      uTextureEmissionWeight;\n"
-   "uniform mat3 uTextureMatrixTransformEmission1;\n"
-   "#endif //EMISSION_TEXTURE_BLEND\n"
-   "#endif //EMISSION\n"
-   "#ifdef LIGHT_SPOT\n"
-   "uniform   vec3  uLightSpotDir;\n"
-   "uniform   float uLightSpotExp;\n"
-   "uniform   float uLightSpotCutoffCos;\n"
-   "#endif //LIGHT_SPOT\n"
-   "#ifdef LIGHT_ATTENUATION\n"
-   "varying   float    vLightDist;\n"
-   "#endif //LIGHT_ATTENUATION\n"
-   "uniform int   uAlphaTestComparison;\n"
-   "uniform float uAlphaTestRefValue;\n"
-   "vec4 fragmentPhong()\n"
-   "{\n"
-   "   vec3  normal = normalize(vNormal);\n"
-   "   vec3  lv = normalize(vLightVector);\n"
-   "   float factor = dot(lv, normal);\n"
-   "   vec4  color;\n"
-   "   vec4 fragcolor;\n"
-   "#ifdef  LIGHT_SPOT\n"
-   "   float f = dot(-lv, normalize(uLightSpotDir));\n"
-   "   if (f > uLightSpotCutoffCos)\n"
-   "      factor *= pow(f, uLightSpotExp);\n"
-   "   else\n"
-   "     factor = 0.0;\n"
-   "#endif //LIGHT_SPOT\n"
-   "   if (factor > 0.0)\n"
-   "     {\n"
-   "   /* Diffuse term. */\n"
-   "#ifdef  DIFFUSE\n"
-   "        \n"
-   "#ifdef  DIFFUSE_TEXTURE_BLEND\n"
-   "   vec3 Tex0CoordDiffuse = vec3(vTexCoord, 1.0) * uTextureMatrixTransformDiffuse0;\n"
-   "   vec3 Tex1CoordDiffuse = vec3(vTexCoord, 1.0) * uTextureMatrixTransformDiffuse1;\n"
-   "   color = mix(texture2D(uTextureDiffuse1, vec2(Tex1CoordDiffuse)),\n"
-   "               texture2D(uTextureDiffuse0, vec2(Tex0CoordDiffuse)), uTextureDiffuseWeight);\n"
-   "   color *= uMaterialDiffuse;\n"
-   "#else\n"
-   "#ifdef  DIFFUSE_TEXTURE\n"
-   "   vec3 Tex0CoordDiffuse = vec3(vTexCoord, 1.0) * uTextureMatrixTransformDiffuse0;\n"
-   "   color = texture2D(uTextureDiffuse0, vec2(Tex0CoordDiffuse)) * uMaterialDiffuse;\n"
-   "#else\n"
-   "   color = uMaterialDiffuse;\n"
-   "#endif //DIFFUSE_TEXTURE\n"
-   "#endif //DIFFUSE_TEXTURE_BLEND\n"
-   "        fragcolor = uLightDiffuse * color * factor;\n"
-   "#else\n"
-   "        fragcolor = vec4(0.0, 0.0, 0.0, 0.0);\n"
-   "#endif //DIFFUSE\n"
-   "   /* Specular term. */\n"
-   "#ifdef SPECULAR\n"
-   "        factor = dot(normalize(vLightHalfVector), normal);\n"
-   "        if (factor > 0.0)\n"
-   "          {\n"
-   "             factor = pow(factor, uMaterialShininess);\n"
-   "             \n"
-   "#ifdef  SPECULAR_TEXTURE_BLEND\n"
-   "   vec3 Tex0CoordSpecular = vec3(vTexCoord, 1.0) * uTextureMatrixTransformSpecular0;\n"
-   "   vec3 Tex1CoordSpecular = vec3(vTexCoord, 1.0) * uTextureMatrixTransformSpecular1;\n"
-   "   color = mix(texture2D(uTextureSpecular1, vec2(Tex1CoordSpecular)),\n"
-   "               texture2D(uTextureSpecular0, vec2(Tex0CoordSpecular)), uTextureSpecularWeight);\n"
-   "   color *= uMaterialSpecular;\n"
-   "#else\n"
-   "#ifdef  SPECULAR_TEXTURE\n"
-   "   vec3 Tex0CoordSpecular = vec3(vTexCoord, 1.0) * uTextureMatrixTransformSpecular0;\n"
-   "   color = texture2D(uTextureSpecular0, vec2(Tex0CoordSpecular)) * uMaterialSpecular;\n"
-   "#else\n"
-   "   color = uMaterialSpecular;\n"
-   "#endif //SPECULAR_TEXTURE\n"
-   "#endif //SPECULAR_TEXTURE_BLEND\n"
-   "             fragcolor += uLightSpecular * color * factor;\n"
-   "          }\n"
-   "#endif\n"
-   "     }\n"
-   "   else\n"
-   "     fragcolor = vec4(0.0, 0.0, 0.0, 0.0);\n"
-   "#ifdef  SHADOWED\n"
-   "   fragcolor *= shadow;\n"
-   "#endif //SHADOWED\n"
-   "#ifdef AMBIENT\n"
-   "   \n"
-   "#ifdef  AMBIENT_TEXTURE_BLEND\n"
-   "   vec3 Tex0CoordAmbient = vec3(vTexCoord, 1.0) * uTextureMatrixTransformAmbient0;\n"
-   "   vec3 Tex1CoordAmbient = vec3(vTexCoord, 1.0) * uTextureMatrixTransformAmbient1;\n"
-   "   color = mix(texture2D(uTextureAmbient1, vec2(Tex1CoordAmbient)),\n"
-   "               texture2D(uTextureAmbient0, vec2(Tex0CoordAmbient)), uTextureAmbientWeight);\n"
-   "   color *= uMaterialAmbient;\n"
-   "#else\n"
-   "#ifdef  AMBIENT_TEXTURE\n"
-   "   vec3 Tex0CoordAmbient = vec3(vTexCoord, 1.0) * uTextureMatrixTransformAmbient0;\n"
-   "   color = texture2D(uTextureAmbient0, vec2(Tex0CoordAmbient)) * uMaterialAmbient;\n"
-   "#else\n"
-   "   color = uMaterialAmbient;\n"
-   "#endif //AMBIENT_TEXTURE\n"
-   "#endif //AMBIENT_TEXTURE_BLEND\n"
-   "   fragcolor += uLightAmbient * color;\n"
-   "#endif\n"
-   "   /* Light attenuation. */\n"
-   "#ifdef  LIGHT_ATTENUATION\n"
-   "   fragcolor /= dot(uLightAtten, vec3(1.0, vLightDist, vLightDist * vLightDist));\n"
-   "#endif\n"
-   "   /* Emission term. */\n"
-   "#ifdef  EMISSION\n"
-   "   \n"
-   "#ifdef  EMISSION_TEXTURE_BLEND\n"
-   "   vec3 Tex0CoordEmission = vec3(vTexCoord, 1.0) * uTextureMatrixTransformEmission0;\n"
-   "   vec3 Tex1CoordEmission = vec3(vTexCoord, 1.0) * uTextureMatrixTransformEmission1;\n"
-   "   color = mix(texture2D(uTextureEmission1, vec2(Tex1CoordEmission)),\n"
-   "               texture2D(uTextureEmission0, vec2(Tex0CoordEmission)), uTextureEmissionWeight);\n"
-   "   color *= uMaterialEmission;\n"
-   "#else\n"
-   "#ifdef  EMISSION_TEXTURE\n"
-   "   vec3 Tex0CoordEmission = vec3(vTexCoord, 1.0) * uTextureMatrixTransformEmission0;\n"
-   "   color = texture2D(uTextureEmission0, vec2(Tex0CoordEmission)) * uMaterialEmission;\n"
-   "#else\n"
-   "   color = uMaterialEmission;\n"
-   "#endif //EMISSION_TEXTURE\n"
-   "#endif //EMISSION_TEXTURE_BLEND\n"
-   "   fragcolor += color;\n"
-   "#endif\n"
-   "   return fragcolor;\n"
-   "}\n"
-   "void main()\n"
-   "{\n"
-   "   vec4 color;\n"
-   "#ifdef SHADOWED\n"
-   "   shadow = pcf(vLightPosition);\n"
-   "#endif //SHADOWED\n"
-   "   color = fragmentPhong();\n"
-   "#ifdef ALPHA_TEST_ENABLED\n"
-   "   /*uAlphaTestComparison is value of the Evas_3D_Comparison type*/\n"
-   "   const float p = 1000000.0;\n"
-   "   float acolor = floor(color.a * p);\n"
-   "   float refvalue = floor(uAlphaTestRefValue * p);\n"
-   "   if (uAlphaTestComparison == 0) discard;\n"
-   "   else if (uAlphaTestComparison == 1)\n"
-   "     {\n"
-   "        if (acolor < refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 2)\n"
-   "     {\n"
-   "        if (acolor == refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 3)\n"
-   "     {\n"
-   "        if (acolor <= refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 4)\n"
-   "     {\n"
-   "        if (acolor > refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 5)\n"
-   "     {\n"
-   "        if (acolor != refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 6)\n"
-   "     {\n"
-   "        if (acolor >= refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 7) ;\n"
-   "#else\n"
-   "   gl_FragColor = color;\n"
-   "#endif //ALPHA_TEST_ENABLED\n"
-   "   \n"
-   "#ifdef FOG_ENABLED\n"
-   "   float z = gl_FragCoord.z / gl_FragCoord.w;\n"
-   "   float fogFactor = exp2(-uFogFactor * uFogFactor * z * z * 1.44);\n"
-   "   fogFactor = clamp(fogFactor, 0.0, 1.0);\n"
-   "   gl_FragColor = mix(uFogColor, gl_FragColor, fogFactor);\n"
-   "#endif //FOG_ENABLED\n"
-   "}\n";
-
-static const char normal_map_vert_glsl[] =
-   "#ifdef GL_ES\n"
-   "precision mediump float;\n"
-   "precision mediump int;\n"
-   "precision lowp sampler2D;\n"
-   "#endif\n"
-   "uniform  mat4  uMatrixMvp;\n"
-   "uniform  mat3  uMatrixNormal;\n"
-   "uniform  mat4  uMatrixModelview;\n"
-   "uniform  vec4  uLightPosition;\n"
-   "varying  vec3  vLightVector;\n"
-   "varying  vec3  vLightHalfVector;\n"
-   "varying  vec3  vEyeVector;\n"
-   "#ifndef VERTEX_TANGENT\n"
-   "varying  vec3  vNormal;\n"
-   "#endif //VERTEX_TANGENT\n"
-   "#ifdef SHADOWED\n"
-   "uniform mat4 uMatrixLight;\n"
-   "varying vec4 vLightPosition;\n"
-   "#endif //SHADOWED\n"
-   "#ifdef VERTEX_POSITION\n"
-   "attribute   vec4  aPosition0;\n"
-   "#endif //VERTEX_POSITION\n"
-   "#ifdef VERTEX_POSITION_BLEND\n"
-   "attribute   vec4  aPosition1;\n"
-   "uniform     float uPositionWeight;\n"
-   "#endif //VERTEX_POSITION_BLEND\n"
-   "#ifdef VERTEX_NORMAL\n"
-   "attribute   vec4  aNormal0;\n"
-   "#endif //VERTEX_NORMAL\n"
-   "#ifdef VERTEX_NORMAL_BLEND\n"
-   "attribute   vec4  aNormal1;\n"
-   "uniform     float uNormalWeight;\n"
-   "#endif //VERTEX_NORMAL_BLEND\n"
-   "#ifdef VERTEX_TANGENT\n"
-   "attribute   vec4  aTangent0;\n"
-   "#endif //VERTEX_TANGENT\n"
-   "#ifdef VERTEX_TANGENT_BLEND\n"
-   "attribute   vec4  aTangent1;\n"
-   "uniform     float uTangentWeight;\n"
-   "#endif //VERTEX_TANGENT_BLEND\n"
-   "#ifdef VERTEX_TEXCOORD\n"
-   "attribute   vec4  aTexCoord0;\n"
-   "#endif //VERTEX_TEXCOORD\n"
-   "#ifdef VERTEX_TEXCOORD_BLEND\n"
-   "attribute   vec4  aTexCoord1;\n"
-   "uniform     float uTexCoordWeight;\n"
-   "#endif //VERTEX_TEXCOORD_BLEND\n"
-   "#ifdef NEED_TEX_COORD\n"
-   "varying vec2 vTexCoord;\n"
-   "#endif //NEED_TEX_COORD\n"
-   "#ifdef LIGHT_ATTENUATION\n"
-   "varying  float vLightDist;\n"
-   "#endif //LIGHT_ATTENUATION\n"
-   "#ifndef VERTEX_TANGENT\n"
-   "void vertexNormalMap(vec4 position, vec3 normal)\n"
-   "{\n"
-   "   normal = uMatrixNormal * normal;\n"
-   "   position = uMatrixModelview * position;\n"
-   "   vEyeVector = normalize(-position.xyz);\n"
-   "#ifdef NORMALIZE_NORMALS\n"
-   "   normal = normalize(normal);\n"
-   "#endif //NORMALIZE_NORMALS\n"
-   "#ifdef LIGHT_DIRECTIONAL\n"
-   "   vLightVector = uLightPosition.xyz;\n"
-   "#else\n"
-   "   vLightVector = uLightPosition.xyz - position.xyz;\n"
-   "#ifdef LIGHT_ATTENUATION\n"
-   "   vLightDist = length(vLightVector);\n"
-   "#endif //LIGHT_ATTENUATION\n"
-   "   vLightVector = normalize(vLightVector);\n"
-   "#endif //LIGHT_DIRECTIONAL\n"
-   "   vLightHalfVector = normalize(vEyeVector + vLightVector);\n"
-   "   vNormal = normal;\n"
-   "}\n"
-   "#else\n"
-   "void vertexNormalMap(vec4 position, vec3 normal, vec3 tangent)\n"
-   "{\n"
-   "   vec3 n = normalize(uMatrixNormal * normal);\n"
-   "   vec3 t = normalize(uMatrixNormal * tangent);\n"
-   "   vec3 b = cross(n, t);\n"
-   "   vec3 tmp;\n"
-   "   position = uMatrixModelview * position;\n"
-   "#ifdef LIGHT_DIRECTIONAL\n"
-   "   vec3 lightDir = uLightPosition.xyz;\n"
-   "#else\n"
-   "   vec3 lightDir = uLightPosition.xyz - position.xyz;\n"
-   "#ifdef LIGHT_ATTENUATION\n"
-   "   vLightDist = length(lightDir);\n"
-   "#endif //LIGHT_ATTENUATION\n"
-   "   lightDir = normalize(lightDir);\n"
-   "#endif //LIGHT_DIRECTIONAL\n"
-   "   tmp.x = dot(lightDir, t);\n"
-   "   tmp.y = dot(lightDir, b);\n"
-   "   tmp.z = dot(lightDir, n);\n"
-   "   vLightVector = tmp;\n"
-   "   tmp.x = dot(position.xyz, t);\n"
-   "   tmp.y = dot(position.xyz, b);\n"
-   "   tmp.z = dot(position.xyz, n);\n"
-   "   vEyeVector = normalize(tmp);\n"
-   "   vec3 hv = normalize(normalize(-position.xyz) + lightDir);\n"
-   "   tmp.x = dot(hv, t);\n"
-   "   tmp.y = dot(hv, b);\n"
-   "   tmp.z = dot(hv, n);\n"
-   "   vLightHalfVector = tmp;\n"
-   "}\n"
-   "#endif //VERTEX_TANGENT\n"
-   "void main()\n"
-   "{\n"
-   "   #ifdef VERTEX_POSITION_BLEND\n"
-   "   vec4 position = mix(aPosition1, aPosition0, uPositionWeight);\n"
-   "   position = vec4(position.xyz, 1.0);\n"
-   "#else\n"
-   "#ifdef VERTEX_POSITION\n"
-   "   vec4 position = vec4(aPosition0.xyz, 1.0);\n"
-   "#endif // VERTEX_POSITION\n"
-   "#endif //VERTEX_POSITION_BLEND\n"
-   "   #ifdef VERTEX_NORMAL_BLEND\n"
-   "   vec3 normal = mix(aNormal1.xyz, aNormal0.xyz, uNormalWeight);\n"
-   "#else\n"
-   "#ifdef VERTEX_NORMAL\n"
-   "   vec3 normal = aNormal0.xyz;\n"
-   "#endif //VERTEX_NORMAL\n"
-   "#endif //VERTEX_NORMAL_BLEND\n"
-   "#ifdef VERTEX_TANGENT_BLEND\n"
-   "   vec3 tangent = aTangent0.xyz * uTangentWeight +\n"
-   "   aTangent1.xyz * (1.0 - uTangentWeight);\n"
-   "#else\n"
-   "#ifdef VERTEX_TANGENT\n"
-   "   vec3 tangent = aTangent0.xyz;\n"
-   "#endif //VERTEX_TANGENT\n"
-   "#endif //VERTEX_TANGENT_BLEND\n"
-   "   #ifdef VERTEX_TEXCOORD_BLEND\n"
-   "   vTexCoord = mix(vec2(aTexCoord1.s, 1.0 - aTexCoord1.t),\n"
-   "                   vec2(aTexCoord0.s, 1.0 - aTexCoord0.t), uTexCoordWeight);\n"
-   "#else\n"
-   "#ifdef VERTEX_TEXCOORD\n"
-   "   vTexCoord = vec2(aTexCoord0.s, 1.0 - aTexCoord0.t);\n"
-   "#endif //VERTEX_TEXCOORD\n"
-   "#endif //VERTEX_TEXCOORD_BLEND\n"
-   "   gl_Position = uMatrixMvp * position;\n"
-   "#ifdef  VERTEX_TANGENT\n"
-   "   vertexNormalMap(position, normal, tangent);\n"
-   "#else\n"
-   "   vertexNormalMap(position, normal);\n"
-   "#endif //VERTEX_TANGENT\n"
-   "#ifdef SHADOWED\n"
-   "   vLightPosition = uMatrixLight * position;\n"
-   "#endif\n"
-   "}\n";
-
-static const char normal_map_frag_glsl[] =
-   "#ifdef GL_ES\n"
-   "precision mediump float;\n"
-   "precision mediump int;\n"
-   "precision lowp sampler2D;\n"
-   "#endif\n"
-   "varying  vec3        vLightVector;\n"
-   "varying  vec3        vLightHalfVector;\n"
-   "varying  vec3        vEyeVector;\n"
-   "#ifdef NEED_TEX_COORD\n"
-   "varying vec2   vTexCoord;\n"
-   "#endif //TEX_COORD\n"
-   "#ifdef FOG_ENABLED\n"
-   "uniform float uFogFactor;\n"
-   "uniform vec4  uFogColor;\n"
-   "#endif //FOG_ENABLED\n"
-   "#ifdef  SHADOWED\n"
-   "varying vec4 vLightPosition;\n"
-   "uniform sampler2D uShadowMap;\n"
-   "uniform float uShadowsPCFStep;\n"
-   "uniform float uShadowsPCFSize;\n"
-   "uniform float uShadowsConstantBias;\n"
-   "float shadow;\n"
-   "float pcf(vec4 lpos)\n"
-   "{\n"
-   "   vec3 smcoord = lpos.xyz / lpos.w * 0.5 + 0.5;\n"
-   "   float i, j, shadow, q, c;\n"
-   "   q = floor(uShadowsPCFStep * 2.0);\n"
-   "   c = floor(uShadowsPCFStep * uShadowsPCFStep * 4.0);\n"
-   "   shadow = 0.0;\n"
-   "   const vec4 unpack = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n"
-   "   for (i = -uShadowsPCFStep; i < uShadowsPCFStep; i += 1.0)\n"
-   "     for (j = -uShadowsPCFStep; j < uShadowsPCFStep; j += 1.0)\n"
-   "       {\n"
-   "          vec4 zvalue = texture2D(uShadowMap, smcoord.xy + vec2(i / q, j / q) * uShadowsPCFSize);\n"
-   "          shadow += float(smcoord.z < dot(zvalue, unpack) + uShadowsConstantBias);\n"
-   "       }\n"
-   "   return shadow / c;\n"
-   "}\n"
-   "#endif //SHADOWED\n"
-   "#ifdef NORMAL_TEXTURE\n"
-   "uniform sampler2D  uTextureNormal0;\n"
-   "uniform mat3 uTextureMatrixTransformNormal0;\n"
-   "#endif //NORMAL_TEXTURE\n"
-   "#ifdef NORMAL_TEXTURE_BLEND\n"
-   "uniform sampler2D  uTextureNormal1;\n"
-   "uniform float      uTextureNormalWeight;\n"
-   "uniform mat3 uTextureMatrixTransformNormal1;\n"
-   "#endif //NORMAL_TEXTURE_BLEND\n"
-   "uniform int   uAlphaTestComparison;\n"
-   "uniform float uAlphaTestRefValue;\n"
-   "#ifndef VERTEX_TANGENT\n"
-   "varying  vec3        vNormal;\n"
-   "#endif //VERTEX_TANGENT\n"
-   "#ifdef DIFFUSE\n"
-   "uniform   vec4        uMaterialDiffuse;\n"
-   "uniform   vec4        uLightDiffuse;\n"
-   "#ifdef DIFFUSE_TEXTURE\n"
-   "uniform sampler2D  uTextureDiffuse0;\n"
-   "uniform mat3 uTextureMatrixTransformDiffuse0;\n"
-   "#endif //DIFFUSE_TEXTURE\n"
-   "#ifdef DIFFUSE_TEXTURE_BLEND\n"
-   "uniform sampler2D  uTextureDiffuse1;\n"
-   "uniform float      uTextureDiffuseWeight;\n"
-   "uniform mat3 uTextureMatrixTransformDiffuse1;\n"
-   "#endif //DIFFUSE_TEXTURE_BLEND\n"
-   "#endif //DIFFUSE\n"
-   "#ifdef SPECULAR\n"
-   "uniform   vec4     uLightSpecular;\n"
-   "uniform   float    uMaterialShininess;\n"
-   "uniform   vec4     uMaterialSpecular;\n"
-   "#ifdef SPECULAR_TEXTURE\n"
-   "uniform sampler2D  uTextureSpecular0;\n"
-   "uniform mat3 uTextureMatrixTransformSpecular0;\n"
-   "#endif //SPECULAR_TEXTURE\n"
-   "#ifdef SPECULAR_TEXTURE_BLEND\n"
-   "uniform sampler2D  uTextureSpecular1;\n"
-   "uniform float      uTextureSpecularWeight;\n"
-   "uniform mat3 uTextureMatrixTransformSpecular1;\n"
-   "#endif //SPECULAR_TEXTURE_BLEND\n"
-   "#endif //SPECULAR\n"
-   "#ifdef AMBIENT\n"
-   "uniform  vec4       uMaterialAmbient;\n"
-   "uniform  vec4       uLightAmbient;\n"
-   "#ifdef AMBIENT_TEXTURE\n"
-   "uniform sampler2D  uTextureAmbient0;\n"
-   "uniform mat3 uTextureMatrixTransformAmbient0;\n"
-   "#endif //AMBIENT_TEXTURE\n"
-   "#ifdef AMBIENT_TEXTURE_BLEND\n"
-   "uniform sampler2D  uTextureAmbient1;\n"
-   "uniform float      uTextureAmbientWeight;\n"
-   "uniform mat3 uTextureMatrixTransformAmbient1;\n"
-   "#endif //AMBIENT_TEXTURE_BLEND\n"
-   "#endif //AMBIENT\n"
-   "#ifdef EMISSION\n"
-   "uniform vec4       uMaterialEmission;\n"
-   "#ifdef EMISSION_TEXTURE\n"
-   "uniform sampler2D  uTextureEmission0;\n"
-   "uniform mat3 uTextureMatrixTransformEmission0;\n"
-   "#endif //EMISSION_TEXTURE\n"
-   "#ifdef EMISSION_TEXTURE_BLEND\n"
-   "uniform sampler2D  uTextureEmission1;\n"
-   "uniform float      uTextureEmissionWeight;\n"
-   "uniform mat3 uTextureMatrixTransformEmission1;\n"
-   "#endif //EMISSION_TEXTURE_BLEND\n"
-   "#endif //EMISSION\n"
-   "#ifdef LIGHT_SPOT\n"
-   "uniform   vec3  uLightSpotDir;\n"
-   "uniform   float uLightSpotExp;\n"
-   "uniform   float uLightSpotCutoffCos;\n"
-   "#endif //LIGHT_SPOT\n"
-   "#ifdef LIGHT_ATTENUATION\n"
-   "varying   float    vLightDist;\n"
-   "#endif //LIGHT_ATTENUATION\n"
-   "#ifndef VERTEX_TANGENT\n"
-   "mat3 cotangent_frame(vec3 n, vec3 p, vec2 uv)\n"
-   "{\n"
-   "   vec3 dp1 = dFdx(p);\n"
-   "   vec3 dp2 = dFdy(p);\n"
-   "   vec2 duv1 = dFdx(uv);\n"
-   "   vec2 duv2 = dFdy(uv);\n"
-   "   vec3 dp2perp = cross(dp2, n);\n"
-   "   vec3 dp1perp = cross(n, dp1);\n"
-   "   vec3 t = dp2perp * duv1.x + dp1perp * duv2.x;\n"
-   "   vec3 b = dp2perp * duv1.y + dp1perp * duv2.y;\n"
-   "   float invmax = inversesqrt(max(dot(t, t), dot(b, b)));\n"
-   "   return mat3(t * invmax, b * invmax, n);\n"
-   "}\n"
-   "vec3 perturb_normal(vec3 normal)\n"
-   "{\n"
-   "   mat3 tbn = cotangent_frame(vNormal, -vEyeVector, vTexCoord);\n"
-   "   return normalize(tbn * normal);\n"
-   "}\n"
-   "#endif //VERTEX_TANGENT\n"
-   "vec4 fragmentNormalMap()\n"
-   "{\n"
-   "   float factor;\n"
-   "   vec3  normal;\n"
-   "   vec4  color;\n"
-   "   vec4 fragcolor;\n"
-   "   vec3 Tex0CoordNormal = vec3(vTexCoord, 1.0) * uTextureMatrixTransformNormal0;\n"
-   "#ifdef NORMAL_TEXTURE_BLEND\n"
-   "   vec3 Tex1CoordNormal = vec3(vTexCoord, 1.0) * uTextureMatrixTransformNormal1;\n"
-   "   normal = texture2D(uTextureNormal0, vec2(Tex0CoordNormal)).rgb * uTextureNormalWeight / texture2D(uTextureNormal0, vec2(Tex0CoordNormal)).a;\n"
-   "   normal += texture2D(uTextureNormal1, vec2(Tex1CoordNormal)).rgb / texture2D(uTextureNormal1, vec2(Tex1CoordNormal)).a *\n"
-   "   (1.0 - uTextureNormalWeight);\n"
-   "#else\n"
-   "   normal = texture2D(uTextureNormal0, vec2(Tex0CoordNormal)).rgb / texture2D(uTextureNormal0, vec2(Tex0CoordNormal)).a;\n"
-   "#endif //NORMAL_TEXTURE_BLEND\n"
-   "   normal = 2.0 * normal - 1.0;\n"
-   "#ifndef VERTEX_TANGENT\n"
-   "   normal = perturb_normal(normal);\n"
-   "#endif //VERTEX_TANGENT\n"
-   "   vec3  lv = normalize(vLightVector);\n"
-   "   normal = normalize(normal);\n"
-   "   factor = dot(lv, normal);\n"
-   "#ifdef LIGHT_SPOT\n"
-   "   float f = dot(-lv, normalize(uLightSpotDir));\n"
-   "   if (f > uLightSpotCutoffCos)\n"
-   "     factor *= pow(f, uLightSpotExp);\n"
-   "   else\n"
-   "     factor = 0.0;\n"
-   "#endif //LIGHT_SPOT\n"
-   "   if (factor > 0.0)\n"
-   "     {\n"
-   "#ifdef DIFFUSE\n"
-   "        \n"
-   "#ifdef  DIFFUSE_TEXTURE_BLEND\n"
-   "   vec3 Tex0CoordDiffuse = vec3(vTexCoord, 1.0) * uTextureMatrixTransformDiffuse0;\n"
-   "   vec3 Tex1CoordDiffuse = vec3(vTexCoord, 1.0) * uTextureMatrixTransformDiffuse1;\n"
-   "   color = mix(texture2D(uTextureDiffuse1, vec2(Tex1CoordDiffuse)),\n"
-   "               texture2D(uTextureDiffuse0, vec2(Tex0CoordDiffuse)), uTextureDiffuseWeight);\n"
-   "   color *= uMaterialDiffuse;\n"
-   "#else\n"
-   "#ifdef  DIFFUSE_TEXTURE\n"
-   "   vec3 Tex0CoordDiffuse = vec3(vTexCoord, 1.0) * uTextureMatrixTransformDiffuse0;\n"
-   "   color = texture2D(uTextureDiffuse0, vec2(Tex0CoordDiffuse)) * uMaterialDiffuse;\n"
-   "#else\n"
-   "   color = uMaterialDiffuse;\n"
-   "#endif //DIFFUSE_TEXTURE\n"
-   "#endif //DIFFUSE_TEXTURE_BLEND\n"
-   "        fragcolor = uLightDiffuse * color * factor;\n"
-   "#else\n"
-   "        fragcolor = vec4(0.0, 0.0, 0.0, 0.0);\n"
-   "#endif //DIFFUSE\n"
-   "#ifdef SPECULAR\n"
-   "        factor = dot(normalize(vLightHalfVector), normal);\n"
-   "        if (factor > 0.0)\n"
-   "          {\n"
-   "             factor = pow(factor, uMaterialShininess);\n"
-   "             \n"
-   "#ifdef  SPECULAR_TEXTURE_BLEND\n"
-   "   vec3 Tex0CoordSpecular = vec3(vTexCoord, 1.0) * uTextureMatrixTransformSpecular0;\n"
-   "   vec3 Tex1CoordSpecular = vec3(vTexCoord, 1.0) * uTextureMatrixTransformSpecular1;\n"
-   "   color = mix(texture2D(uTextureSpecular1, vec2(Tex1CoordSpecular)),\n"
-   "               texture2D(uTextureSpecular0, vec2(Tex0CoordSpecular)), uTextureSpecularWeight);\n"
-   "   color *= uMaterialSpecular;\n"
-   "#else\n"
-   "#ifdef  SPECULAR_TEXTURE\n"
-   "   vec3 Tex0CoordSpecular = vec3(vTexCoord, 1.0) * uTextureMatrixTransformSpecular0;\n"
-   "   color = texture2D(uTextureSpecular0, vec2(Tex0CoordSpecular)) * uMaterialSpecular;\n"
-   "#else\n"
-   "   color = uMaterialSpecular;\n"
-   "#endif //SPECULAR_TEXTURE\n"
-   "#endif //SPECULAR_TEXTURE_BLEND\n"
-   "             fragcolor += uLightSpecular * color * factor;\n"
-   "          }\n"
-   "#endif //SPECULAR\n"
-   "#ifdef SHADOWED\n"
-   "        fragcolor *= shadow;\n"
-   "#endif //SHADOWED\n"
-   "     }\n"
-   "   else\n"
-   "     fragcolor = vec4(0.0, 0.0, 0.0, 0.0);\n"
-   "#ifdef AMBIENT\n"
-   "     \n"
-   "#ifdef  AMBIENT_TEXTURE_BLEND\n"
-   "   vec3 Tex0CoordAmbient = vec3(vTexCoord, 1.0) * uTextureMatrixTransformAmbient0;\n"
-   "   vec3 Tex1CoordAmbient = vec3(vTexCoord, 1.0) * uTextureMatrixTransformAmbient1;\n"
-   "   color = mix(texture2D(uTextureAmbient1, vec2(Tex1CoordAmbient)),\n"
-   "               texture2D(uTextureAmbient0, vec2(Tex0CoordAmbient)), uTextureAmbientWeight);\n"
-   "   color *= uMaterialAmbient;\n"
-   "#else\n"
-   "#ifdef  AMBIENT_TEXTURE\n"
-   "   vec3 Tex0CoordAmbient = vec3(vTexCoord, 1.0) * uTextureMatrixTransformAmbient0;\n"
-   "   color = texture2D(uTextureAmbient0, vec2(Tex0CoordAmbient)) * uMaterialAmbient;\n"
-   "#else\n"
-   "   color = uMaterialAmbient;\n"
-   "#endif //AMBIENT_TEXTURE\n"
-   "#endif //AMBIENT_TEXTURE_BLEND\n"
-   "     fragcolor += uLightAmbient * color;\n"
-   "#endif //AMBIENT\n"
-   "#ifdef LIGHT_ATTENUATION\n"
-   "   fragcolor /= dot(uLightAtten, vec3(1.0, vLightDist, vLightDist * vLightDist));\n"
-   "#endif //LIGHT_ATTENUATION\n"
-   "#ifdef EMISSION\n"
-   "   \n"
-   "#ifdef  EMISSION_TEXTURE_BLEND\n"
-   "   vec3 Tex0CoordEmission = vec3(vTexCoord, 1.0) * uTextureMatrixTransformEmission0;\n"
-   "   vec3 Tex1CoordEmission = vec3(vTexCoord, 1.0) * uTextureMatrixTransformEmission1;\n"
-   "   color = mix(texture2D(uTextureEmission1, vec2(Tex1CoordEmission)),\n"
-   "               texture2D(uTextureEmission0, vec2(Tex0CoordEmission)), uTextureEmissionWeight);\n"
-   "   color *= uMaterialEmission;\n"
-   "#else\n"
-   "#ifdef  EMISSION_TEXTURE\n"
-   "   vec3 Tex0CoordEmission = vec3(vTexCoord, 1.0) * uTextureMatrixTransformEmission0;\n"
-   "   color = texture2D(uTextureEmission0, vec2(Tex0CoordEmission)) * uMaterialEmission;\n"
-   "#else\n"
-   "   color = uMaterialEmission;\n"
-   "#endif //EMISSION_TEXTURE\n"
-   "#endif //EMISSION_TEXTURE_BLEND\n"
-   "   fragcolor += color;\n"
-   "#endif //EMISSION\n"
-   "   return fragcolor;\n"
-   "}\n"
-   "void main() {\n"
-   "   vec4 color;\n"
-   "#ifdef SHADOWED\n"
-   "   shadow = pcf(vLightPosition);\n"
-   "#endif //SHADOWED\n"
-   "   color = fragmentNormalMap();\n"
-   "#ifdef ALPHA_TEST_ENABLED\n"
-   "   /*uAlphaTestComparison is value of the Evas_3D_Comparison type*/\n"
-   "   const float p = 1000000.0;\n"
-   "   float acolor = floor(color.a * p);\n"
-   "   float refvalue = floor(uAlphaTestRefValue * p);\n"
-   "   if (uAlphaTestComparison == 0) discard;\n"
-   "   else if (uAlphaTestComparison == 1)\n"
-   "     {\n"
-   "        if (acolor < refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 2)\n"
-   "     {\n"
-   "        if (acolor == refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 3)\n"
-   "     {\n"
-   "        if (acolor <= refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 4)\n"
-   "     {\n"
-   "        if (acolor > refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 5)\n"
-   "     {\n"
-   "        if (acolor != refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 6)\n"
-   "     {\n"
-   "        if (acolor >= refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 7) ;\n"
-   "#else\n"
-   "   gl_FragColor = color;\n"
-   "#endif //ALPHA_TEST_ENABLED\n"
-   "#ifdef FOG_ENABLED\n"
-   "   float z = gl_FragCoord.z / gl_FragCoord.w;\n"
-   "   float fogFactor = exp2(-uFogFactor * uFogFactor * z * z * 1.44);\n"
-   "   fogFactor = clamp(fogFactor, 0.0, 1.0);\n"
-   "   gl_FragColor = mix(uFogColor, gl_FragColor, fogFactor);\n"
-   "#endif //FOG_ENABLED\n"
-   "}\n";
-
-static const char shadow_map_vert_glsl[] =
-   "#ifdef GL_ES\n"
-   "precision mediump float;\n"
-   "precision mediump int;\n"
-   "precision lowp sampler2D;\n"
-   "#endif\n"
-   "uniform mat4  uMatrixMvp;\n"
-   "varying vec4 shadowmapposition;\n"
-   "#ifdef VERTEX_POSITION\n"
-   "attribute   vec4  aPosition0;\n"
-   "#endif //VERTEX_POSITION\n"
-   "#ifdef VERTEX_POSITION_BLEND\n"
-   "attribute   vec4  aPosition1;\n"
-   "uniform     float uPositionWeight;\n"
-   "#endif //VERTEX_POSITION_BLEND\n"
-   "#ifdef ALPHA_TEST_ENABLED\n"
-   "#ifdef VERTEX_TEXCOORD\n"
-   "attribute   vec4  aTexCoord0;\n"
-   "#endif //VERTEX_TEXCOORD\n"
-   "#ifdef VERTEX_TEXCOORD_BLEND\n"
-   "attribute   vec4  aTexCoord1;\n"
-   "uniform     float uTexCoordWeight;\n"
-   "#endif //VERTEX_TEXCOORD_BLEND\n"
-   "#ifdef NEED_TEX_COORD\n"
-   "varying vec2 vTexCoord;\n"
-   "#endif //NEED_TEX_COORD\n"
-   "#endif //ALPHA_TEST_ENABLED\n"
-   "void main()\n"
-   "{\n"
-   "#ifdef VERTEX_POSITION_BLEND\n"
-   "   vec4 position = mix(aPosition1, aPosition0, uPositionWeight);\n"
-   "   position = vec4(position.xyz, 1.0);\n"
-   "#else\n"
-   "#ifdef VERTEX_POSITION\n"
-   "   vec4 position = vec4(aPosition0.xyz, 1.0);\n"
-   "#endif // VERTEX_POSITION\n"
-   "#endif //VERTEX_POSITION_BLEND\n"
-   "#ifdef ALPHA_TEST_ENABLED\n"
-   "   #ifdef VERTEX_TEXCOORD_BLEND\n"
-   "   vTexCoord = mix(vec2(aTexCoord1.s, 1.0 - aTexCoord1.t),\n"
-   "                   vec2(aTexCoord0.s, 1.0 - aTexCoord0.t), uTexCoordWeight);\n"
-   "#else\n"
-   "#ifdef VERTEX_TEXCOORD\n"
-   "   vTexCoord = vec2(aTexCoord0.s, 1.0 - aTexCoord0.t);\n"
-   "#endif //VERTEX_TEXCOORD\n"
-   "#endif //VERTEX_TEXCOORD_BLEND\n"
-   "#endif //ALPHA_TEST_ENABLED\n"
-   "   gl_Position = uMatrixMvp * position;\n"
-   "   shadowmapposition = gl_Position;\n"
-   "}\n";
-
-static const char shadow_map_frag_glsl[] =
-   "#ifdef GL_ES\n"
-   "precision mediump float;\n"
-   "precision mediump int;\n"
-   "precision lowp sampler2D;\n"
-   "#endif\n"
-   "varying vec4 shadowmapposition;\n"
-   "#ifdef ALPHA_TEST_ENABLED\n"
-   "#ifdef NEED_TEX_COORD\n"
-   "varying vec2   vTexCoord;\n"
-   "#endif //TEX_COORD\n"
-   "uniform int   uAlphaTestComparison;\n"
-   "uniform float uAlphaTestRefValue;\n"
-   "#ifdef DIFFUSE\n"
-   "#ifdef DIFFUSE_TEXTURE\n"
-   "uniform sampler2D  uTextureDiffuse0;\n"
-   "uniform mat3 uTextureMatrixTransformDiffuse0;\n"
-   "#endif //DIFFUSE_TEXTURE\n"
-   "#ifdef DIFFUSE_TEXTURE_BLEND\n"
-   "uniform sampler2D  uTextureDiffuse1;\n"
-   "uniform float      uTextureDiffuseWeight;\n"
-   "uniform mat3 uTextureMatrixTransformDiffuse1;\n"
-   "#endif //DIFFUSE_TEXTURE_BLEND\n"
-   "#endif //DIFFUSE\n"
-   "#endif //ALPHA_TEST_ENABLED\n"
-   "void main() {\n"
-   "   vec4 color;\n"
-   "#ifndef NEED_TEX_COORD\n"
-   "   gl_FragColor = vec4(1);\n"
-   "#endif\n"
-   "#ifdef ALPHA_TEST_ENABLED\n"
-   "#ifdef DIFFUSE_TEXTURE_BLEND\n"
-   "   vec3 Tex1CoordDiffuse = vec3(vTexCoord, 1.0) * uTextureMatrixTransformDiffuse1;\n"
-   "   color = (texture2D(uTextureDiffuse0, vec2(Tex0CoordDiffuse)) *\n"
-   "   uTextureDiffuseWeight + texture2D(uTextureDiffuse1, vec2(Tex1CoordDiffuse)) *\n"
-   "   (1.0 - uTextureDiffuseWeight));\n"
-   "#else\n"
-   "#ifdef DIFFUSE_TEXTURE\n"
-   "   vec3 Tex0CoordDiffuse = vec3(vTexCoord, 1.0) * uTextureMatrixTransformDiffuse0;\n"
-   "   color = texture2D(uTextureDiffuse0, vec2(Tex0CoordDiffuse));\n"
-   "#else\n"
-   "   color = vec4(1);\n"
-   "#endif //DIFFUSE_TEXTURE\n"
-   "#endif //DIFFUSE_TEXTURE_BLEND\n"
-   "   /*uAlphaTestComparison is value of the Evas_3D_Comparison type*/\n"
-   "   const float p = 1000000.0;\n"
-   "   float acolor = floor(color.a * p);\n"
-   "   float refvalue = floor(uAlphaTestRefValue * p);\n"
-   "   if (uAlphaTestComparison == 0) discard;\n"
-   "   else if (uAlphaTestComparison == 1)\n"
-   "     {\n"
-   "        if (acolor < refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 2)\n"
-   "     {\n"
-   "        if (acolor == refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 3)\n"
-   "     {\n"
-   "        if (acolor <= refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 4)\n"
-   "     {\n"
-   "        if (acolor > refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 5)\n"
-   "     {\n"
-   "        if (acolor != refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 6)\n"
-   "     {\n"
-   "        if (acolor >= refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 7) ;\n"
-   "#endif //ALPHA_TEST_ENABLED\n"
-   "   const vec4 pack = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\n"
-   "   const vec4 mask = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n"
-   "   vec4 depthcolor;\n"
-   "   float normdist = shadowmapposition.z / shadowmapposition.w;\n"
-   "   normdist = ((normdist + 1.0) / 2.0);\n"
-   "   depthcolor = vec4(fract(pack * normdist));\n"
-   "   depthcolor -= depthcolor.xxyz * mask;\n"
-   "   gl_FragColor = depthcolor;\n"
-   "}\n";
-
-static const char color_pick_vert_glsl[] =
-   "#ifdef GL_ES\n"
-   "precision mediump float;\n"
-   "precision mediump int;\n"
-   "precision lowp sampler2D;\n"
-   "#endif\n"
-   "uniform mat4  uMatrixMvp;\n"
-   "#ifdef VERTEX_POSITION\n"
-   "attribute   vec4  aPosition0;\n"
-   "#endif //VERTEX_POSITION\n"
-   "#ifdef VERTEX_POSITION_BLEND\n"
-   "attribute   vec4  aPosition1;\n"
-   "uniform     float uPositionWeight;\n"
-   "#endif //VERTEX_POSITION_BLEND\n"
-   "void main()\n"
-   "{\n"
-   "   #ifdef VERTEX_POSITION_BLEND\n"
-   "   vec4 position = mix(aPosition1, aPosition0, uPositionWeight);\n"
-   "   position = vec4(position.xyz, 1.0);\n"
-   "#else\n"
-   "#ifdef VERTEX_POSITION\n"
-   "   vec4 position = vec4(aPosition0.xyz, 1.0);\n"
-   "#endif // VERTEX_POSITION\n"
-   "#endif //VERTEX_POSITION_BLEND\n"
-   "   gl_Position = uMatrixMvp * position;\n"
-   "}\n";
-
-static const char color_pick_frag_glsl[] =
-   "#ifdef GL_ES\n"
-   "precision mediump float;\n"
-   "precision mediump int;\n"
-   "precision lowp sampler2D;\n"
-   "#endif\n"
-   "uniform vec4  uColorPick;\n"
-   "uniform int   uAlphaTestComparison;\n"
-   "uniform float uAlphaTestRefValue;\n"
-   "void main()\n"
-   "{\n"
-   "   vec4 color = uColorPick;\n"
-   "#ifdef ALPHA_TEST_ENABLED\n"
-   "   /*uAlphaTestComparison is value of the Evas_3D_Comparison type*/\n"
-   "   const float p = 1000000.0;\n"
-   "   float acolor = floor(color.a * p);\n"
-   "   float refvalue = floor(uAlphaTestRefValue * p);\n"
-   "   if (uAlphaTestComparison == 0) discard;\n"
-   "   else if (uAlphaTestComparison == 1)\n"
-   "     {\n"
-   "        if (acolor < refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 2)\n"
-   "     {\n"
-   "        if (acolor == refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 3)\n"
-   "     {\n"
-   "        if (acolor <= refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 4)\n"
-   "     {\n"
-   "        if (acolor > refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 5)\n"
-   "     {\n"
-   "        if (acolor != refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 6)\n"
-   "     {\n"
-   "        if (acolor >= refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 7) ;\n"
-   "#else\n"
-   "   gl_FragColor = color;\n"
-   "#endif //ALPHA_TEST_ENABLED\n"
-   "}\n";
-
-static const char parallax_occlusion_vert_glsl[] =
-   "#ifdef GL_ES\n"
-   "precision mediump float;\n"
-   "precision mediump int;\n"
-   "precision lowp sampler2D;\n"
-   "#endif\n"
-   "uniform  mat4  uMatrixMvp;\n"
-   "uniform  mat3  uMatrixNormal;\n"
-   "uniform  mat4  uMatrixModelview;\n"
-   "uniform  vec4  uLightPosition;\n"
-   "varying  vec3  vLightVector;\n"
-   "varying  vec3  vLightHalfVector;\n"
-   "varying  vec3  vEyeVector;\n"
-   "#ifdef SHADOWED\n"
-   "uniform mat4 uMatrixLight;\n"
-   "varying vec4 vLightPosition;\n"
-   "#endif //SHADOWED\n"
-   "#ifdef VERTEX_POSITION\n"
-   "attribute   vec4  aPosition0;\n"
-   "#endif //VERTEX_POSITION\n"
-   "#ifdef VERTEX_POSITION_BLEND\n"
-   "attribute   vec4  aPosition1;\n"
-   "uniform     float uPositionWeight;\n"
-   "#endif //VERTEX_POSITION_BLEND\n"
-   "#ifdef VERTEX_NORMAL\n"
-   "attribute   vec4  aNormal0;\n"
-   "#endif //VERTEX_NORMAL\n"
-   "#ifdef VERTEX_NORMAL_BLEND\n"
-   "attribute   vec4  aNormal1;\n"
-   "uniform     float uNormalWeight;\n"
-   "#endif //VERTEX_NORMAL_BLEND\n"
-   "#ifdef VERTEX_TANGENT\n"
-   "attribute   vec4  aTangent0;\n"
-   "#endif //VERTEX_TANGENT\n"
-   "#ifdef VERTEX_TANGENT_BLEND\n"
-   "attribute   vec4  aTangent1;\n"
-   "uniform     float uTangentWeight;\n"
-   "#endif //VERTEX_TANGENT_BLEND\n"
-   "#ifdef VERTEX_TEXCOORD\n"
-   "attribute   vec4  aTexCoord0;\n"
-   "#endif //VERTEX_TEXCOORD\n"
-   "#ifdef VERTEX_TEXCOORD_BLEND\n"
-   "attribute   vec4  aTexCoord1;\n"
-   "uniform     float uTexCoordWeight;\n"
-   "#endif //VERTEX_TEXCOORD_BLEND\n"
-   "#ifdef NEED_TEX_COORD\n"
-   "varying vec2 vTexCoord;\n"
-   "#endif //NEED_TEX_COORD\n"
-   "#ifdef LIGHT_ATTENUATION\n"
-   "varying  float vLightDist;\n"
-   "#endif //LIGHT_ATTENUATION\n"
-   "void vertexParallaxOcclusion(vec4 position, vec3 normal, vec3 tangent)\n"
-   "{\n"
-   "   vec3 n = normalize(uMatrixNormal * normal);\n"
-   "   vec3 t = normalize(uMatrixNormal * tangent);\n"
-   "   vec3 b = cross(n, t);\n"
-   "   vec3 tmp;\n"
-   "   position = uMatrixModelview * position;\n"
-   "#ifdef LIGHT_DIRECTIONAL\n"
-   "   vec3 lightDir = uLightPosition.xyz;\n"
-   "#else\n"
-   "   vec3 lightDir = uLightPosition.xyz - position.xyz;\n"
-   "#ifdef LIGHT_ATTENUATION\n"
-   "   vLightDist = length(lightDir);\n"
-   "#endif //LIGHT_ATTENUATION\n"
-   "   lightDir = normalize(lightDir);\n"
-   "#endif //LIGHT_DIRECTIONAL\n"
-   "   tmp.x = dot(lightDir, t);\n"
-   "   tmp.y = dot(lightDir, b);\n"
-   "   tmp.z = dot(lightDir, n);\n"
-   "   vLightVector = tmp;\n"
-   "   tmp.x = dot(position.xyz, t);\n"
-   "   tmp.y = dot(position.xyz, b);\n"
-   "   tmp.z = dot(position.xyz, n);\n"
-   "   vEyeVector = normalize(tmp);\n"
-   "   vec3 hv = normalize(normalize(-position.xyz) + lightDir);\n"
-   "   tmp.x = dot(hv, t);\n"
-   "   tmp.y = dot(hv, b);\n"
-   "   tmp.z = dot(hv, n);\n"
-   "   vLightHalfVector = tmp;\n"
-   "}\n"
-   "void main()\n"
-   "{\n"
-   "   #ifdef VERTEX_POSITION_BLEND\n"
-   "   vec4 position = mix(aPosition1, aPosition0, uPositionWeight);\n"
-   "   position = vec4(position.xyz, 1.0);\n"
-   "#else\n"
-   "#ifdef VERTEX_POSITION\n"
-   "   vec4 position = vec4(aPosition0.xyz, 1.0);\n"
-   "#endif // VERTEX_POSITION\n"
-   "#endif //VERTEX_POSITION_BLEND\n"
-   "   #ifdef VERTEX_NORMAL_BLEND\n"
-   "   vec3 normal = mix(aNormal1.xyz, aNormal0.xyz, uNormalWeight);\n"
-   "#else\n"
-   "#ifdef VERTEX_NORMAL\n"
-   "   vec3 normal = aNormal0.xyz;\n"
-   "#endif //VERTEX_NORMAL\n"
-   "#endif //VERTEX_NORMAL_BLEND\n"
-   "#ifdef VERTEX_TANGENT_BLEND\n"
-   "   vec3 tangent = aTangent0.xyz * uTangentWeight +\n"
-   "   aTangent1.xyz * (1.0 - uTangentWeight);\n"
-   "#else\n"
-   "#ifdef VERTEX_TANGENT\n"
-   "   vec3 tangent = aTangent0.xyz;\n"
-   "#endif //VERTEX_TANGENT\n"
-   "#endif //VERTEX_TANGENT_BLEND\n"
-   "   #ifdef VERTEX_TEXCOORD_BLEND\n"
-   "   vTexCoord = mix(vec2(aTexCoord1.s, 1.0 - aTexCoord1.t),\n"
-   "                   vec2(aTexCoord0.s, 1.0 - aTexCoord0.t), uTexCoordWeight);\n"
-   "#else\n"
-   "#ifdef VERTEX_TEXCOORD\n"
-   "   vTexCoord = vec2(aTexCoord0.s, 1.0 - aTexCoord0.t);\n"
-   "#endif //VERTEX_TEXCOORD\n"
-   "#endif //VERTEX_TEXCOORD_BLEND\n"
-   "   gl_Position = uMatrixMvp * position;\n"
-   "   vertexParallaxOcclusion(position, normal, tangent);\n"
-   "   #ifdef SHADOWED\n"
-   "   vLightPosition = uMatrixLight * position;\n"
-   "#endif //SHADOWED\n"
-   "}\n";
-
-static const char parallax_occlusion_frag_glsl[] =
-   "#ifdef GL_ES\n"
-   "precision mediump float;\n"
-   "precision mediump int;\n"
-   "precision lowp sampler2D;\n"
-   "#endif\n"
-   "varying  vec3        vLightVector;\n"
-   "varying  vec3        vLightHalfVector;\n"
-   "varying  vec3        vEyeVector;\n"
-   "uniform  sampler2D   uTextureNormal0;\n"
-   "uniform  mat3        uTextureMatrixTransformNormal0;\n"
-   "#ifdef NEED_TEX_COORD\n"
-   "varying vec2   vTexCoord;\n"
-   "vec3 Tex0CoordNormal;\n"
-   "#endif //TEX_COORD\n"
-   "#ifdef NORMAL_TEXTURE_BLEND\n"
-   "uniform  sampler2D  uTextureNormal1;\n"
-   "uniform  float      uTextureNormalWeight;\n"
-   "uniform mat3 uTextureMatrixTransformNormal1;\n"
-   "vec3 Tex1CoordNormal;\n"
-   "#endif //NORMAL_TEXTURE_BLEND\n"
-   "#ifdef FOG_ENABLED\n"
-   "uniform float uFogFactor;\n"
-   "uniform vec4  uFogColor;\n"
-   "#endif //FOG_ENABLED\n"
-   "#ifdef  SHADOWED\n"
-   "varying vec4 vLightPosition;\n"
-   "uniform sampler2D uShadowMap;\n"
-   "uniform float uShadowsPCFStep;\n"
-   "uniform float uShadowsPCFSize;\n"
-   "uniform float uShadowsConstantBias;\n"
-   "float shadow;\n"
-   "float pcf(vec4 lpos)\n"
-   "{\n"
-   "   vec3 smcoord = lpos.xyz / lpos.w * 0.5 + 0.5;\n"
-   "   float i, j, shadow, q, c;\n"
-   "   q = floor(uShadowsPCFStep * 2.0);\n"
-   "   c = floor(uShadowsPCFStep * uShadowsPCFStep * 4.0);\n"
-   "   shadow = 0.0;\n"
-   "   const vec4 unpack = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n"
-   "   for (i = -uShadowsPCFStep; i < uShadowsPCFStep; i += 1.0)\n"
-   "     for (j = -uShadowsPCFStep; j < uShadowsPCFStep; j += 1.0)\n"
-   "       {\n"
-   "          vec4 zvalue = texture2D(uShadowMap, smcoord.xy + vec2(i / q, j / q) * uShadowsPCFSize);\n"
-   "          shadow += float(smcoord.z < dot(zvalue, unpack) + uShadowsConstantBias);\n"
-   "       }\n"
-   "   return shadow / c;\n"
-   "}\n"
-   "#endif //SHADOWED\n"
-   "#ifdef DIFFUSE\n"
-   "uniform   vec4        uMaterialDiffuse;\n"
-   "uniform   vec4        uLightDiffuse;\n"
-   "#ifdef DIFFUSE_TEXTURE\n"
-   "uniform sampler2D  uTextureDiffuse0;\n"
-   "uniform mat3 uTextureMatrixTransformDiffuse0;\n"
-   "#endif //DIFFUSE_TEXTURE\n"
-   "#ifdef DIFFUSE_TEXTURE_BLEND\n"
-   "uniform sampler2D  uTextureDiffuse1;\n"
-   "uniform float      uTextureDiffuseWeight;\n"
-   "uniform mat3 uTextureMatrixTransformDiffuse1;\n"
-   "#endif //DIFFUSE_TEXTURE_BLEND\n"
-   "#endif //DIFFUSE\n"
-   "#ifdef SPECULAR\n"
-   "uniform   vec4     uLightSpecular;\n"
-   "uniform   float    uMaterialShininess;\n"
-   "uniform   vec4     uMaterialSpecular;\n"
-   "#ifdef SPECULAR_TEXTURE\n"
-   "uniform sampler2D  uTextureSpecular0;\n"
-   "uniform mat3 uTextureMatrixTransformSpecular0;\n"
-   "#endif //SPECULAR_TEXTURE\n"
-   "#ifdef SPECULAR_TEXTURE_BLEND\n"
-   "uniform sampler2D  uTextureSpecular1;\n"
-   "uniform float      uTextureSpecularWeight;\n"
-   "uniform mat3 uTextureMatrixTransformSpecular1;\n"
-   "#endif //SPECULAR_TEXTURE_BLEND\n"
-   "#endif //SPECULAR\n"
-   "#ifdef AMBIENT\n"
-   "uniform  vec4       uMaterialAmbient;\n"
-   "uniform  vec4       uLightAmbient;\n"
-   "#ifdef AMBIENT_TEXTURE\n"
-   "uniform sampler2D  uTextureAmbient0;\n"
-   "uniform mat3 uTextureMatrixTransformAmbient0;\n"
-   "#endif //AMBIENT_TEXTURE\n"
-   "#ifdef AMBIENT_TEXTURE_BLEND\n"
-   "uniform sampler2D  uTextureAmbient1;\n"
-   "uniform float      uTextureAmbientWeight;\n"
-   "uniform mat3 uTextureMatrixTransformAmbient1;\n"
-   "#endif //AMBIENT_TEXTURE_BLEND\n"
-   "#endif //AMBIENT\n"
-   "#ifdef EMISSION\n"
-   "uniform vec4       uMaterialEmission;\n"
-   "#ifdef EMISSION_TEXTURE\n"
-   "uniform sampler2D  uTextureEmission0;\n"
-   "uniform mat3 uTextureMatrixTransformEmission0;\n"
-   "#endif //EMISSION_TEXTURE\n"
-   "#ifdef EMISSION_TEXTURE_BLEND\n"
-   "uniform sampler2D  uTextureEmission1;\n"
-   "uniform float      uTextureEmissionWeight;\n"
-   "uniform mat3 uTextureMatrixTransformEmission1;\n"
-   "#endif //EMISSION_TEXTURE_BLEND\n"
-   "#endif //EMISSION\n"
-   "#ifdef LIGHT_SPOT\n"
-   "uniform   vec3  uLightSpotDir;\n"
-   "uniform   float uLightSpotExp;\n"
-   "uniform   float uLightSpotCutoffCos;\n"
-   "#endif //LIGHT_SPOT\n"
-   "#ifdef LIGHT_ATTENUATION\n"
-   "varying   float    vLightDist;\n"
-   "#endif //LIGHT_ATTENUATION\n"
-   "uniform int   uAlphaTestComparison;\n"
-   "uniform float uAlphaTestRefValue;\n"
-   "const float parallaxScale = 0.2;\n"
-   "vec2 parallaxMapping(in vec3 view, in vec2 tex, out float parallaxHeight)\n"
-   "{\n"
-   "   const float numLayers = 15.0;\n"
-   "   vec2 texStep = parallaxScale * view.xy / view.z / numLayers;\n"
-   "   float layerHeight = 1.0 / numLayers;\n"
-   "   float curLayerHeight = 0.0;\n"
-   "   vec2 dtex = parallaxScale * view.xy / view.z / numLayers;\n"
-   "   vec2 currentTextureCoords = tex;\n"
-   "#ifdef NORMAL_TEXTURE_BLEND\n"
-   "   float heightFromTexture = (1.0 - texture2D(uTextureNormal0, vec2(Tex0CoordNormal)).a) * uTextureNormalWeight;\n"
-   "   heightFromTexture += (1.0 - texture2D(uTextureNormal1, vec2(Tex1CoordNormal)).a) *\n"
-   "   (1.0 - uTextureNormalWeight);\n"
-   "#else\n"
-   "   float heightFromTexture = 1.0 - texture2D(uTextureNormal0, currentTextureCoords).a;\n"
-   "#endif //NORMAL_TEXTURE_BLEND\n"
-   "   while(heightFromTexture > curLayerHeight)\n"
-   "   {\n"
-   "      curLayerHeight += layerHeight;\n"
-   "      currentTextureCoords -= dtex;\n"
-   "#ifdef NORMAL_TEXTURE_BLEND\n"
-   "      heightFromTexture = (1.0 - texture2D(uTextureNormal0, currentTextureCoords).a) * uTextureNormalWeight;\n"
-   "      heightFromTexture += (1.0 - texture2D(uTextureNormal1, currentTextureCoords).a) *\n"
-   "      (1.0 - uTextureNormalWeight);\n"
-   "#else\n"
-   "      heightFromTexture = 1.0 - texture2D(uTextureNormal0, currentTextureCoords).a;\n"
-   "#endif //NORMAL_TEXTURE_BLEND\n"
-   "   }\n"
-   "   vec2 prevTCoords = currentTextureCoords + texStep;\n"
-   "   float nextH = heightFromTexture - curLayerHeight;\n"
-   "#ifdef NORMAL_TEXTURE_BLEND\n"
-   "   float prevH = (1.0 - texture2D(uTextureNormal0, prevTCoords).a\n"
-   "                           - curLayerHeight + layerHeight) * uTextureNormalWeight;\n"
-   "   prevH += (1.0 - texture2D(uTextureNormal1, prevTCoords).a\n"
-   "                           - curLayerHeight + layerHeight) * (1.0 - uTextureNormalWeight);\n"
-   "#else\n"
-   "   float prevH = 1.0 - texture2D(uTextureNormal0, prevTCoords).a\n"
-   "                           - curLayerHeight + layerHeight;\n"
-   "#endif //NORMAL_TEXTURE_BLEND\n"
-   "   float weight = nextH / (nextH - prevH);\n"
-   "   vec2 finalTexCoords = prevTCoords * weight + currentTextureCoords * (1.0-weight);\n"
-   "   parallaxHeight = curLayerHeight + prevH * weight + nextH * (1.0 - weight);\n"
-   "   return finalTexCoords;\n"
-   "}\n"
-   "vec4 fragmentParallaxMap()\n"
-   "{\n"
-   "   float factor;\n"
-   "   vec3  normal;\n"
-   "   vec4  color;\n"
-   "   vec4 fragcolor;\n"
-   "   float parallaxHeight;\n"
-   "   vec2 tex = parallaxMapping(vEyeVector, vec2(Tex0CoordNormal), parallaxHeight);\n"
-   "   vec3  lv = normalize(vLightVector);\n"
-   "#ifdef NORMAL_TEXTURE_BLEND\n"
-   "   normal = texture2D(uTextureNormal0, tex).rgb * uTextureNormalWeight / texture2D(uTextureNormal0, tex).a;\n"
-   "   normal += texture2D(uTextureNormal1, tex).rgb *\n"
-   "   (1.0 - uTextureNormalWeight) / texture2D(uTextureNormal1, tex).a;\n"
-   "#else\n"
-   "   normal = texture2D(uTextureNormal0, tex).rgb / texture2D(uTextureNormal0, tex).a;\n"
-   "#endif //NORMAL_TEXTURE_BLEND\n"
-   "   normal = 2.0 * normal - 1.0;\n"
-   "   normal = normalize(normal);\n"
-   "   factor = dot(lv, normal);\n"
-   "#ifdef LIGHT_SPOT\n"
-   "   float f = dot(-lv, normalize(uLightSpotDir));\n"
-   "   if (f > uLightSpotCutoffCos)\n"
-   "     factor *= pow(f, uLightSpotExp);\n"
-   "   else\n"
-   "     factor = 0.0;\n"
-   "#endif //LIGHT_SPOT\n"
-   "   if (factor > 0.0)\n"
-   "     {\n"
-   "#ifdef DIFFUSE\n"
-   "#ifdef DIFFUSE_TEXTURE_BLEND\n"
-   "        color = texture2D(uTextureDiffuse0, tex) * uTextureDiffuseWeight +\n"
-   "        texture2D(uTextureDiffuse1, tex) * (1.0 - uTextureDiffuseWeight);\n"
-   "#else\n"
-   "#ifdef DIFFUSE_TEXTURE\n"
-   "        color = texture2D(uTextureDiffuse0, tex);\n"
-   "#else\n"
-   "        color = uMaterialDiffuse;\n"
-   "#endif //DIFFUSE_TEXTURE\n"
-   "#endif //DIFFUSE_TEXTURE_BLEND\n"
-   "        fragcolor = uLightDiffuse * color * factor;\n"
-   "#else\n"
-   "        fragcolor = vec4(0.0, 0.0, 0.0, 0.0);\n"
-   "#endif //DIFFUSE\n"
-   "#ifdef SPECULAR\n"
-   "        factor = dot(normalize(vLightHalfVector), normal);\n"
-   "        if (factor > 0.0)\n"
-   "          {\n"
-   "             factor = pow(factor, uMaterialShininess);\n"
-   "#ifdef SPECULAR_TEXTURE_BLEND\n"
-   "             color = texture2D(uTextureSpecular0, tex) * uTextureSpecularWeight +\n"
-   "             texture2D(uTextureSpecular1, tex) * (1.0 - uTextureSpecularWeight);\n"
-   "#else\n"
-   "#ifdef SPECULAR_TEXTURE\n"
-   "             color = texture2D(uTextureSpecular0, tex);\n"
-   "#else\n"
-   "             color = uMaterialSpecular;\n"
-   "#endif //SPECULAR_TEXTURE\n"
-   "#endif //SPECULAR_TEXTURE_BLEND\n"
-   "             fragcolor += uLightSpecular * color * factor;\n"
-   "          }\n"
-   "#endif //SPECULAR\n"
-   "#ifdef SHADOWED\n"
-   "        fragcolor *= shadow;\n"
-   "#endif //SHADOWED\n"
-   "     }\n"
-   "   else\n"
-   "     fragcolor = vec4(0.0, 0.0, 0.0, 0.0);\n"
-   "#ifdef AMBIENT\n"
-   "#ifdef AMBIENT_TEXTURE_BLEND\n"
-   "   color = texture2D(uTextureAmbient0, tex) * uTextureAmbientWeight +\n"
-   "   texture2D(uTextureAmbient1, tex) * (1.0 - uTextureAmbientWeight);\n"
-   "#else\n"
-   "#ifdef AMBIENT_TEXTURE\n"
-   "   color = texture2D(uTextureAmbient0, tex);\n"
-   "#else\n"
-   "   color = uMaterialAmbient;\n"
-   "#endif //AMBIENT_TEXTURE\n"
-   "#endif //AMBIENT_TEXTURE_BLEND\n"
-   "   fragcolor += uLightAmbient * color;\n"
-   "#endif //AMBIENT\n"
-   "#ifdef LIGHT_ATTENUATION\n"
-   "   fragcolor /= dot(uLightAtten, vec3(1.0, vLightDist, vLightDist * vLightDist));\n"
-   "#endif //LIGHT_ATTENUATION\n"
-   "#ifdef EMISSION\n"
-   "#ifdef EMISSION_TEXTURE_BLEND\n"
-   "   color = texture2D(uTextureEmission0, tex) * uTextureEmissionWeight +\n"
-   "   texture2D(uTextureEmission1, tex) * (1.0 - uTextureEmissionWeight);\n"
-   "#else\n"
-   "#ifdef EMISSION_TEXTURE\n"
-   "   color = texture2D(uTextureEmission0, tex);\n"
-   "#else\n"
-   "   color = uMaterialEmission;\n"
-   "#endif //EMISSION_TEXTURE\n"
-   "#endif //EMISSION_TEXTURE_BLEND\n"
-   "   fragcolor += color;\n"
-   "#endif //EMISSION\n"
-   "   return fragcolor;\n"
-   "}\n"
-   "void main() {\n"
-   "   vec4 color;\n"
-   "#ifdef NEED_TEX_COORD\n"
-   "   Tex0CoordNormal = vec3(vTexCoord, 1.0) * uTextureMatrixTransformNormal0;\n"
-   "#endif // NEED_TEX_COORD\n"
-   "#ifdef NORMAL_TEXTURE_BLEND\n"
-   "   Tex1CoordNormal = vec3(vTexCoord, 1.0) * uTextureMatrixTransformNormal1;\n"
-   "#endif //NORMAL_TEXTURE_BLEND\n"
-   "#ifdef SHADOWED\n"
-   "   shadow = pcf(vLightPosition);\n"
-   "#endif //SHADOWED\n"
-   "   color = fragmentParallaxMap();\n"
-   "#ifdef ALPHA_TEST_ENABLED\n"
-   "   /*uAlphaTestComparison is value of the Evas_3D_Comparison type*/\n"
-   "   const float p = 1000000.0;\n"
-   "   float acolor = floor(color.a * p);\n"
-   "   float refvalue = floor(uAlphaTestRefValue * p);\n"
-   "   if (uAlphaTestComparison == 0) discard;\n"
-   "   else if (uAlphaTestComparison == 1)\n"
-   "     {\n"
-   "        if (acolor < refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 2)\n"
-   "     {\n"
-   "        if (acolor == refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 3)\n"
-   "     {\n"
-   "        if (acolor <= refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 4)\n"
-   "     {\n"
-   "        if (acolor > refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 5)\n"
-   "     {\n"
-   "        if (acolor != refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 6)\n"
-   "     {\n"
-   "        if (acolor >= refvalue) gl_FragColor = color;\n"
-   "        else discard;\n"
-   "     }\n"
-   "   else if (uAlphaTestComparison == 7) ;\n"
-   "#else\n"
-   "   gl_FragColor = color;\n"
-   "#endif //ALPHA_TEST_ENABLED\n"
-   "   \n"
-   "#ifdef FOG_ENABLED\n"
-   "   float z = gl_FragCoord.z / gl_FragCoord.w;\n"
-   "   float fogFactor = exp2(-uFogFactor * uFogFactor * z * z * 1.44);\n"
-   "   fogFactor = clamp(fogFactor, 0.0, 1.0);\n"
-   "   gl_FragColor = mix(uFogColor, gl_FragColor, fogFactor);\n"
-   "#endif //FOG_ENABLED\n"
-   "}\n";
-
-static const char post_processing_fxaa_vert_glsl[] =
-   "#ifdef GL_ES\n"
-   "precision mediump float;\n"
-   "precision mediump int;\n"
-   "precision lowp sampler2D;\n"
-   "#endif\n"
-   "uniform mat4  uMatrixMvp;\n"
-   "#ifdef VERTEX_POSITION\n"
-   "attribute   vec4  aPosition0;\n"
-   "#endif //VERTEX_POSITION\n"
-   "#ifdef VERTEX_POSITION_BLEND\n"
-   "attribute   vec4  aPosition1;\n"
-   "uniform     float uPositionWeight;\n"
-   "#endif //VERTEX_POSITION_BLEND\n"
-   "varying vec2 tc0;\n"
-   "void main()\n"
-   "{\n"
-   "   #ifdef VERTEX_POSITION_BLEND\n"
-   "   vec4 position = mix(aPosition1, aPosition0, uPositionWeight);\n"
-   "   position = vec4(position.xyz, 1.0);\n"
-   "#else\n"
-   "#ifdef VERTEX_POSITION\n"
-   "   vec4 position = vec4(aPosition0.xyz, 1.0);\n"
-   "#endif // VERTEX_POSITION\n"
-   "#endif //VERTEX_POSITION_BLEND\n"
-   "   gl_Position = uMatrixMvp * position;\n"
-   "   tc0 = position.xy * 0.5 + 0.5;\n"
-   "}\n";
-
-static const char post_processing_fxaa_frag_glsl[] =
-   "#ifdef GL_ES\n"
-   "precision mediump float;\n"
-   "precision mediump int;\n"
-   "precision lowp sampler2D;\n"
-   "#endif\n"
-   "//FXAA fragment shader by Timothy Lottes\n"
-   "//http://developer.download.nvidia.com/assets/gamedev/files/sdk/11/FXAA_WhitePaper.pdf\n"
-   "//modified and adapted to www.enlightenment.org by Oleksander Shcherbina\n"
-   "uniform sampler2D uColorTexture;\n"
-   "uniform float uFrameSizeH;\n"
-   "uniform float uFrameSizeW;\n"
-   "varying vec2 tc0;\n"
-   "vec4 fxaa()\n"
-   "{\n"
-   "   float _SPAN_MAX_ = 8.0;\n"
-   "   float _REDUCE_MUL_ = (1.0/8.0);\n"
-   "   float _REDUCE_MIN_ = (1.0/128.0);\n"
-   "   vec4 l = vec4(0.299, 0.587, 0.114, 0.0);\n"
-   "   vec2 frameBufSize = vec2(uFrameSizeW, uFrameSizeH);\n"
-   "   vec2 direction;\n"
-   "   vec4 colorNW = texture2D(uColorTexture, tc0 + (vec2(-1.0, -1.0)/frameBufSize));\n"
-   "   vec4 colorNE = texture2D(uColorTexture, tc0 + (vec2(1.0, -1.0)/frameBufSize));\n"
-   "   vec4 colorSW = texture2D(uColorTexture, tc0 + (vec2(-1.0, 1.0)/frameBufSize));\n"
-   "   vec4 colorSE = texture2D(uColorTexture, tc0 + (vec2(1.0, 1.0)/frameBufSize));\n"
-   "   vec4 colorM = texture2D(uColorTexture,tc0);\n"
-   "   float lNW = dot(colorNW, l);\n"
-   "   float lNE = dot(colorNE, l);\n"
-   "   float lSW = dot(colorSW, l);\n"
-   "   float lSE = dot(colorSE, l);\n"
-   "   float lM  = dot(colorM,  l);\n"
-   "   float lMin = min(lM, min(min(lNW, lNE), min(lSW, lSE)));\n"
-   "   float lMax = max(lM, max(max(lNW, lNE), max(lSW, lSE)));\n"
-   "   direction.x = -((lNW + lNE) - (lSW + lSE));\n"
-   "   direction.y = ((lNW + lSW) - (lNE + lSE));\n"
-   "   float directionReduce = max(\n"
-   "          (lNW + lNE + lSW + lSE) * (0.25 * _REDUCE_MUL_),\n"
-   "          _REDUCE_MIN_);\n"
-   "   float rcpDirMin = 1.0/(min(abs(direction.x), abs(direction.y)) + directionReduce);\n"
-   "   direction = min(vec2(_SPAN_MAX_,  _SPAN_MAX_),\n"
-   "             max(vec2(-_SPAN_MAX_, -_SPAN_MAX_),\n"
-   "             direction * rcpDirMin)) / frameBufSize;\n"
-   "   vec4 colorA = 0.5 * (\n"
-   "          texture2D(uColorTexture, tc0.xy + direction * (1.0/3.0 - 0.5)) +\n"
-   "          texture2D(uColorTexture, tc0.xy + direction * (2.0/3.0 - 0.5)));\n"
-   "   vec4 colorB = colorA * 0.5 + 0.25 * (\n"
-   "          texture2D(uColorTexture, tc0.xy + direction * (- 0.5)) +\n"
-   "          texture2D(uColorTexture, tc0.xy + direction * 0.5));\n"
-   "   float lB = dot(colorB, l);\n"
-   "   if((lB < lMin) || (lB > lMax))\n"
-   "     return colorA;\n"
-   "   else\n"
-   "     return colorB;\n"
-   "}\n"
-   "void main()\n"
-   "{\n"
-   "   gl_FragColor = fxaa();\n"
-   "}\n";
-
-static const char *vertex_shaders[] =
-{
-    vertex_color_vert_glsl,
-    diffuse_vert_glsl,
-    flat_vert_glsl,
-    phong_vert_glsl,
-    normal_map_vert_glsl,
-    shadow_map_vert_glsl,
-    color_pick_vert_glsl,
-    parallax_occlusion_vert_glsl,
-    post_processing_fxaa_vert_glsl,
-};
-
-static const char *fragment_shaders[] =
-{
-    vertex_color_frag_glsl,
-    diffuse_frag_glsl,
-    flat_frag_glsl,
-    phong_frag_glsl,
-    normal_map_frag_glsl,
-    shadow_map_frag_glsl,
-    color_pick_frag_glsl,
-    parallax_occlusion_frag_glsl,
-    post_processing_fxaa_frag_glsl,
-};
--- a/src/Makefile_Ector.am
+++ b/src/Makefile_Ector.am
@@ -145,6 +145,8 @@
 	@echo "  SHADERS  $@"
 	@sh $(srcdir)/lib/ector/gl/shader/gen_shaders.sh
 
+lib/ector/gl/ector_gl_shader.c: lib/ector/gl/shader/ector_gl_shaders.x
+
 lib_ector_libector_la_CPPFLAGS = -I$(top_builddir)/src/lib/efl \
 -I$(top_builddir)/src/lib/ector \
 -I$(top_builddir)/src/lib/ector/cairo \
--- a/src/lib/ector/gl/shader/gen_shaders.sh
+++ b/src/lib/ector/gl/shader/gen_shaders.sh
@@ -6,14 +6,6 @@
 
 OUTPUT="$DIR/ector_gl_shaders.x"
 
-# Skip generation if there is no diff (or no git)
-if ! git rev-parse 2>> /dev/null >> /dev/null ; then exit 0 ; fi
-if git diff --quiet --exit-code -- "$DIR"
-then
-  touch "$OUTPUT"
-  exit 0
-fi
-
 exec 1<&-
 exec 1>"$OUTPUT"
 
--- a/src/modules/evas/engines/gl_common/shader_3d/gen_shaders_3d.sh
+++ b/src/modules/evas/engines/gl_common/shader_3d/gen_shaders_3d.sh
@@ -3,24 +3,10 @@
 # This script will generate a C file containing all the shaders used by Evas_3D
 
 DIR=`dirname $0`
-cd $DIR/../../../../../
+cd $DIR/../../../../../../
 
 OUTPUT="$DIR/evas_gl_3d_shaders.x"
 
-# Skip generation during make distcheck
-if [ "${top_distdir}" != "" ] ; then exit 0; fi
-
-# Skip generation if file can not be written to
-if [ -e ${OUTPUT} ] && [ ! -w ${OUTPUT} ] ; then exit 0; fi
-
-# Skip generation if there is no diff (or no git)
-if ! git rev-parse 2>> /dev/null >> /dev/null ; then exit 0 ; fi
-if git diff --quiet --exit-code -- "$DIR"
-then
-  touch "$OUTPUT"
-  exit 0
-fi
-
 exec 1<&-
 exec 1>"$OUTPUT"
 
--- a/src/modules/evas/engines/gl_common/shader/gen_shaders.sh
+++ b/src/modules/evas/engines/gl_common/shader/gen_shaders.sh
@@ -3,24 +3,10 @@
 # This script will generate a C file containing all the shaders used by Evas
 
 DIR=`dirname $0`
-cd $DIR/../../../../../
+cd $DIR/../../../../../../
 
 OUTPUT="$DIR/evas_gl_shaders.x"
 
-# Skip generation during make distcheck
-if [ "${top_distdir}" != "" ] ; then exit 0; fi
-
-# Skip generation if file can not be written to
-if [ -e ${OUTPUT} ] && [ ! -w ${OUTPUT} ] ; then exit 0; fi
-
-# Skip generation if there is no diff (or no git)
-if ! git rev-parse 2>> /dev/null >> /dev/null ; then exit 0 ; fi
-if git diff --quiet --exit-code -- "$DIR"
-then
-  touch "$OUTPUT"
-  exit 0
-fi
-
 exec 1<&-
 exec 1>"$OUTPUT"
 
